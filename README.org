# Hey Emacs, this is a -*- org -*- file ...
#+TITLE:     Refcard SQL
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION: SQL cheat sheet for quick reference
#+KEYWORDS:  SQL, database, quick reference, SQL Server, Oracle, Emacs, snippets, code templates
#+LANGUAGE:  en
#+OPTIONS:   H:4 num:nil toc:3
#+EXCLUDE_TAGS: noexport

#+PROPERTY:  header-args :eval never :padline no :tangle yes

#+SETUPFILE: ~/org/theme-readtheorg.setup

Welcome to Refcard SQL!  This project provides a concise and handy reference for
SQL syntax and commands, designed to improve your productivity and proficiency.

* Tasks                                                               :noexport:

** TODO Perform a textual search over all fields in all tables for a specific value!!! (for checking results of anonymization)

https://stackoverflow.com/questions/208493/search-all-fields-in-all-tables-for-a-specific-value-oracle

** TODO Watch video of SQL Prompt

http://www.red-gate.com/products/sql-development/sql-prompt/

** TODO Look at RedGate snippets

=/cygdrive/c/Users/f.niessen/AppData/Local/Red Gate/SQL Prompt 7/Snippets/=

** TODO Look at SQL Query syntax checker & validator

https://www.eversql.com/sql-syntax-check-validator/

* SQL Clients

** SQL Server Management Studio

Free add-ins for SQL Server Management Studio.

See https://alessandroalpi.blog/2013/07/24/ssms-boost-another-cool-addin-for-sql-server-management-studio/

*** SSMSBoost

- Format SQL Code
- Auto replacements (or "snippets") allow you to write frequently used SQL
  commands more quickly
- Copy as SQL values List
- Fatal Actions Guard (DELETE without WHERE, UPDATE without WHERE, TRUNCATE)
- Intellisense Completion Fix
- Connection management
- Locate object
- Go to definition
- Template scripter
- Visualizers
- Grid management

*** SSMS Tools Pack (by Mladen Pradjc)

- Regions - you can create region of code (-#region -#endregion) which can be
  collapsed/expanded
- History and session management - you can recover previous sessions or commands
  from a history tab
- Debug sections - you can add a comment in order to try a script in "debug" or
  "release" (different executions with commented areas)
- Execution plan analyzer - you can watch execution plans with a deeper
  perspective (with alerting and more statistics)

*** SQL Prompt (by Red-Gate)

- Format SQL and coding style - you can choose how to format your T-SQL with
  a huge set of options (uppercase/lowercase, joins, aliases, indentation and so
  on)
- Tab coloring (experimental) - your tab will change color based on
  environment. Actually this is simpler than the window connection coloring by
  SSMSToolsPack, but more useful for me.  I suggest the SSMSToolsPack one if you
  need more customizations.
- Point to synonyms (experimental) - when autocompletes, the plugin suggests and
  inspects also the synonyms.
- Enhanced intellisense - your autocomplete experience will be improved
  a lot. You can also go to a definition/summary of an object in a popup
  (without changing tabs) and pick the columns in case of tables.

** SQL Developer

Shortcuts:
- F5 :: execute a "whole" script by pressing.
- F9 :: execute a statement (highlighted commands).

*** How to export query result to CSV in Oracle SQL Developer?

To export results to CSV from SQL Developer:

1. Run a query

2. Right-click and select "Export...".  See
   http://stackoverflow.com/questions/4168398/how-to-export-query-result-to-csv-in-oracle-sql-developer#4169011

3. Select "XLS" from the format drop down ("CSV" produces results over multiple
   lines!)

4. In Excel, convert to CSV (as well over multiple lines!)

5. In Emacs, replace end-of-lines ~^M~ by ~^M^J^J~ so that you have clear paragraphs
   to work on

6. Change ~fill-column~ to ~10000~

7. Apply ~M-q~ on all paragraphs via a macro

** DBeaver

- Supports any database that has a JDBC or ODBC driver: *SQL Server*, *Oracle*,
  PostgreSQL, MySQL, DB2 and many others.
- Windows, Linux, macOS
- Free (community)
- *SQL Templates* -- snippets of SQL code that you use frequently
- Data and metadata search
- C-S-SPC for words completion (so-called "hippie autocomplete") -- it completes
  word trying to find any identifiers matching you input in all open editors.

*** Settings

- Preferences
  + Editors
    - SQL Editor
      + SQL Completion
        Insert case (https://dbeaver.io/forum/, Possibility to disable auto content assist)

*** Windows Authentication for SQL Server

See [[https://github.com/dbeaver/dbeaver/issues/8251][Error resolving driver dependencies mssql-jdbc_auth]].

** Sqsh

#+name: current-year
#+begin_src emacs-lisp :eval yes :results silent :tangle no :exports none
(format-time-string "%Y")
#+end_src

#+begin_src conf :tangle .sqshrc
# Hey Emacs, this is a -*- conf -*- file
## .sqshrc - My sqsh initialization file

# Copyright (C) 2010-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fni" at-symbol "pirilampo.org")>
# Keywords: sqsh, dotfile, config

#* Connections

# Setting your password within your `.sqshrc' is probably the most secure method
# of using sqsh.  However, make sure that you `chmod go-rwx ~/.sqshrc',
# otherwise you leave yourself wide open to attacks.

\set username="sa"
\set password="mysecret"
\set hostname="localhost"
\set database=[ARCHIBUS_23_2_HQ]

#* Aliasing

#** Display styles

# \set colsep='| '

# Currently supported styles are:
# - horiz (or hor or horizontal) (*) = default
# - vert (or vertical) (*),
# - bcp,
# - csv,
# - html,
# - meta,
# - pretty (*), and
# - none.

\alias goh='\go -m horiz | ${PAGER}'

\alias gov='\go -m vert | ${PAGER}'

# *Very* useful for doing quick bcp commands from command line, and using
# re-direction directly to a file!
\alias gob='\go -m bcp | ${PAGER}'

# Firefox.
\alias gof='\go -m html | (cat > /tmp/sqsh-output.html; /mnt/c/Windows/explorer.exe file:///tmp/sqsh-output.html)'

\alias gom='\go -m meta | ${PAGER}'

\alias gop='\go -m pretty -w80 | ${PAGER}'

#** Aliases for T-SQL commands
#+end_src

#+begin_src conf :tangle .sqshrc
\alias statson='\loop -e "SET STATISTICS IO ON; SET STATISTICS TIME ON;"'
\alias statsoff='\loop -e "SET STATISTICS IO OFF; SET STATISTICS TIME OFF;"'
#+end_src

SQL Server Execution Time: This refers to the time taken by SQL server to
complete the execution of the compiled plan.

*CPU time* refers to the actual time spent on CPU.

The *elapsed time* is the total time to complete the execution which includes
- signal wait time,
- wait time to complete the IO operation and
- time taken to transfer the output to the client.

*CPU time* is really where you want to pay attention for *performance tuning*, as it
can be
- higher than the *elapsed time* if the query goes parallel, or
- lower if the procedure spends time sleeping on wait signals and I/O
  operations.

The *CPU time* can be used to baseline the performance tuning. This value will not
vary much from execution to execution unless you modify the query or data. The
load on the server will not impact much on this value.

The *elapsed time* will depend on many factors, like load on the server, IO load,
network bandwidth between server and client.

So always use the CPU time as baseline while doing the performance tuning.

Want to *format your output* online in a web browser?  The [[http://statisticsparser.com/index.html][Statistics Parser]] will
help with that. Just paste in the output of Statistics IO and/or Statistics Time
and press Parse. Your output will be formatted and totaled. Enjoy.

#+begin_src conf :tangle .sqshrc
\alias planon='\loop -e "SET SHOWPLAN ON"'
\alias planoff='\loop -e "SET SHOWPLAN OFF"'

\alias ton='\loop -e "DBCC TRACEON(3604)"'
\alias toff='\loop -e "DBCC TRACEOFF(3604)"'

\alias tempdb='\loop -e "USE tempdb"'
\alias master='\loop -e "USE master"'

#** Aliases for sqsh commands

\alias DEV='\reconnect -SDEV -Usa -Pmysecret'
\alias STG='\reconnect -SSTG -Usa -Pmysecret'
\alias PRD='\reconnect -c -SPRD -Usa -Pmysecret'

# Clear screen within sqsh session.
\alias clear="\shell clear"

# Read a file into sqsh session.
\alias :r='\buf-load -a !*'
\alias r="\buf-load "

# Drop you into a shell out of sqsh.
\alias sh="\shell "

\alias h="\history"

\alias xx='\reset'

\alias q="\exit"

#* Miscellaneous

# Turn off the sqsh banner; cosmetic only
\set banner=no

\set width=65535

# Have semicolons executing commands (sort of inline "go")...
\set semicolon_hack=on

# Turn on ability to have !-recall commands.
\set history_shorthand=on

# This variable causes sqsh to exit with an exit status of the total number of
# batches that failed during the current session.  This is useful for use within
# shell scripts and the such.
\set exit_failcount=on

\set prompt_color='{0;34;47}'
\set text_color='{0;33}'
\set prompt='$prompt_color{{$username@$DSQUERY:$database}}>$text_color '

# This is for the sake of Emacs.
# Local Variables:
# mode: outline-minor
# End:

## .sqshrc ends here
#+end_src

** Mssql-cli

*** Features

New and interactive command line query tool for SQL Server. This open source
tool works cross-platform and is a proud member of the dbcli community.

Features
- Mssql-cli auto-completion that is context aware
- T-SQL IntelliSense
- Syntax highlighting
- Pretty formatting for query results, including Vertical Format
- Multi-line edit mode
- Configuration file support

https://cloudblogs.microsoft.com/sqlserver/2017/12/12/try-mssql-cli-a-new-interactive-command-line-tool-for-sql-server/

*** Setup

#+begin_src shell :tangle no
sudo apt install python-pip python-dev
sudo pip install --upgrade pip
sudo pip install mssql-cli
#+end_src

#+begin_src shell :tangle no
mssql-cli -E
kinit.exe user@domain.com
#+end_src

* Database Comparison Tools

- DBCompare: a database comparison tool that allows you to compare and
  synchronize database structures and data.

- RedGate: a suite of tools for database management and administration,
  including backup and recovery, monitoring, and performance tuning.

- DataGrip: a multi-engine database IDE that supports multiple databases such as
  MySQL, PostgreSQL, Oracle, and SQL Server, and provides advanced coding
  assistance, schema navigation, and data analysis features.

* Emacs YASnippets

A *SQL "snippet"* (or *auto-replacement*) is a frequently used *code template* which
can be inserted into a code you are typing by pressing the TAB key.  It allows
you to write frequently used SQL commands more quickly.

Snippets are categorized into 2 types:

- *Insert Snippets (or Expansion Snippets)*: These are code templates for various
  SQL commands you can quickly insert into your SQL code when creating tables,
  stored procedures, triggers and so on.

- *Surround Snippets:* These are code templates that help you implement code
  constructs such as ~BEGIN...END~, ~IF~, ~WHILE~ and so on.

See https://github.com/gvohra/sqlpromptsnippets or sharing the best Red Gate SQL
Prompt snippets.

https://www.ssmsboost.com/

https://www.ssmstoolspack.com/Download

** Insert Snippet...

*** Cursor

**** [curff] Cursor Fast-Forward

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/curff.yasnippet
# name: Fast-forward read-on...
# --
/* declare variables */
DECLARE @variable INT

DECLARE ${1:cursor_name} CURSOR
FAST_FORWARD READ_ONLY
FOR ${2:select_statement}

OPEN $1

FETCH NEXT FROM $1
INTO @variable

WHILE @@FETCH_STATUS = 0
BEGIN
    $0

    FETCH NEXT FROM $1
    INTO @variable
END

CLOSE $1
DEALLOCATE $1
go
#+end_src

*** Database

**** [cdb] Create DataBase

Create database.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/cdb.yasnippet
# name: Create database
# --
USE master
go

-- Drop the database if it already exists.
IF EXISTS (SELECT name
        FROM sys.databases
        WHERE name = N'${1:database_name}')
    DROP DATABASE $1
go

CREATE DATABASE $1
ON
PRIMARY ( -- or use FILEGROUP filegroup_name
  NAME = $1_data,
  FILENAME = '$1.mdf'
) --, and repeat as required
LOG ON
(
  NAME = $1_log,
  FILENAME = '$1.ldf'
) --, and repeat as required
--COLLATE collation_name
--WITH
--  DB_CHAINING ON/OFF
--  TRUSTWORTHY ON/OFF
--FOR LOAD
--FOR ATTACH
--WITH
--  ENABLE_BROKER
--  NEW_BROKER
--  ERROR_BROKER_CONVERSATIONS
--FOR ATTACH_REBUILD_LOG
go
#+end_src

**** [cdbsnap] Create DataBase Snapshot

Create snapshot.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/cdbsnap.yasnippet
# name: Create database sna...
# --
USE master
go

-- Drop snapshot database if it already exists.
IF EXISTS (SELECT name
        FROM sys.databases
        WHERE name = N'${1:source_database}_${2:snapshot_id}')
    DROP DATABASE $1_$2
go

-- Create the snapshot database.
CREATE DATABASE $1_$2 ON
( NAME = $1_$2_data,
  FILENAME = '$1_$2.ss')
AS SNAPSHOT OF $1;
go$0
#+end_src

**** [dd] Drop Database

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/dd.yasnippet
# name: Drop database
# --
USE master
go

-- Drop the database if it already exists.
IF EXISTS (SELECT name
        FROM sys.databases
        WHERE name = N'${1:database_name}')
    DROP DATABASE $1
go
#+end_src

**** Database Backup

Backup database.

#+begin_src sql :tangle no
# name: Backup database
# --
BACKUP DATABASE ${1:database_name}
    TO DISK = N'Backup_Path/$1.bak'
WITH
    NOFORMAT,
    NOINIT,
    NAME = N'$1-Full Database Backup',
    SKIP,
    STATS = 10;
go
#+end_src

**** Database Restore

Restore database.

#+begin_src sql :tangle no
# name: Restore database
# --
USE master
go

RESTORE DATABASE ${1:database_name}
    FROM DISK = N'Backup_Path/$1.bak'
WITH
    FILE = 1,
    NOUNLOAD,
    REPLACE,
    STATS = 10
go
#+end_src

*** Fragment

**** [cr] Create

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/cr.yasnippet
# name: Create fragment
# --
CREATE $0
#+end_src

**** [i] Insert

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/i.yasnippet
# name: INSERT fragment
# --
INSERT
#+end_src

**** [ii] Insert Into

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ii.yasnippet
# name: INSERT INTO fragment
# --
INSERT INTO $0 ()
VALUES ()
#+end_src

**** [s] Select

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/s.yasnippet
# name: SELECT fragment
# --
SELECT
#+end_src

**** [ssf] Select Star From

~SELECT~ with condition.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ssf.yasnippet
# name: SELECT * FROM frag...
# --
SELECT *
FROM $0
WHERE
#+end_src

**** [sst] Select Top 10

Select top 10 rows.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/sst.yasnippet
# name: SELECT top 10 rows
# --
SELECT TOP 10 *
FROM $0
#+end_src

**** [st100] Select Top 100

Select top 100 rows.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/st100.yasnippet
# name: SELECT top 100 rows
# --
SELECT TOP 100 *
FROM $0
#+end_src

**** [scf] Select Count From

Count number of records returned by query.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/scf.yasnippet
# name: Count number of rec...
# --
SELECT FORMAT(COUNT(*), '#,##0')
FROM $0
#+end_src

**** [scgb] Select Count with Group By

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/scgb.yasnippet
# name: Count with group by
# --
SELECT ${1:col}, COUNT(*)
FROM $0
GROUP BY $1
#+end_src

**** [num] Format Number

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/num.yasnippet
# name: Format number
# --
FORMAT($0,'#,##0')
#+end_src

**** [smf] Select Sum From

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/smf.yasnippet
# name: SELECT SUM(*) FROM...
# --
SELECT SUM($0)
FROM
#+end_src

**** [f] From

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/f.yasnippet
# name: FROM fragment
# --
FROM
#+end_src

**** [is] INFORMATION_SCHEMA

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/is.yasnippet
# name: INFORMATION_SCH...
# --
INFORMATION_SCHEMA$0
#+end_src

**** [w] Where

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/w.yasnippet
# name: WHERE fragment
# --
WHERE $0
#+end_src

**** [lk] Like

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/lk.yasnippet
# name: LIKE fragment
# --
LIKE '%$0%'
#+end_src

#+begin_warning
By default, in Oracle, the ~LIKE~ comparisons are treated in a *case-sensitive*
manner!!!
#+end_warning

**** [today] Today

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/today.yasnippet
# name: Today fragment
# --
CAST(GETDATE() AS DATE)
#+end_src

**** [now] Now

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/now.yasnippet
# name: Now fragment
# --
`(format-time-string "'%Y-%m-%d %H:%M:%S.%3N'")`
#+end_src

**** [gb] Group By

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/gb.yasnippet
# name: GROUP BY fragment
# --
GROUP BY $0
#+end_src

**** [ha] Having

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ha.yasnippet
# name: HAVING fragment
# --
HAVING
#+end_src

**** [ob] Order By

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ob.yasnippet
# name: ORDER BY fragment
# --
ORDER BY $0
#+end_src

**** [rwn] Row Number

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/rwn.yasnippet
# name: ROW_NUMBER fragment
# --
ROW_NUMBER() OVER(PARTITION BY $0 ORDER BY )
#+end_src

Example:

#+begin_src sql :tangle no
cteEtpNumBCEDernNom AS
(
    SELECT etpSiegeExpNumBCE, etpNom
    FROM
    (
        SELECT
            etpSiegeExpNumBCE,
            etpNom,
            SUBSTRING(pfiID, 4, 11)     AS date_part,
            ROW_NUMBER() OVER(PARTITION BY etpSiegeExpNumBCE
                              ORDER BY SUBSTRING(pfiID, 4, 11) DESC)
                                        AS rn
        FROM entreprise
        WHERE etpSiegeExpNumBCE IS NOT NULL
    ) data
    WHERE rn = 1
)
#+end_src

**** [up] Update

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/up.yasnippet
# name: UPDATE fragment
# --
UPDATE $0
#+end_src

**** [upd] Update

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/upd.yasnippet
# name: UPDATE fragment
# --
UPDATE $0
SET
WHERE
#+end_src

**** [d] Delete

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/d.yasnippet
# name: DELETE frag...
# --
DELETE
#+end_src

**** [df] Delete From

Delete statement.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/df.yasnippet
# name: DELETE FROM frag...
# --
DELETE FROM ${1:[schema].[table_name]}
WHERE $0
#+end_src

**** [tt] Truncate Table

Truncate statement.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/tt.yasnippet
# name: TRUNCATE fragment
# --
TRUNCATE TABLE $0
#+end_src

**** [lin]

to split up code

**** [linn]

as above, with space for commentary

**** [header]

as above, with even  more space

**** [deci] Declare Int

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/deci.yasnippet
# name: DECLARE int fragment
# --
DECLARE @$0 int
#+end_src

**** [decv] Declare Varchar

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/decv.yasnippet
# name: DECLARE varchar fragment
# --
DECLARE @$0 varchar(256)
#+end_src

**** [be] Begin...End

Insert ~BEGIN...END~ block.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/be.yasnippet
# name: BEGIN...END block
# --
BEGIN
    $0
END
#+end_src

**** [tc] Try ... Catch

Insert ~TRY...CATCH~ block.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/tc.yasnippet
# name: TRY ... CATCH fragm...
# --
BEGIN TRY
    $0
END TRY
BEGIN CATCH
    /*
        SELECT
            ERROR_NUMBER() AS ErrorNumber,
            ERROR_SEVERITY() AS ErrorSeverity,
            ERROR_STATE() AS ErrorState,
            ERROR_PROCEDURE() AS ErrorProcedure,
            ERROR_LINE() AS ErrorLine,
            ERROR_MESSAGE() AS ErrorMessage
    */
END CATCH;
#+end_src

**** [ifs] If

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ifs.yasnippet
# name: IF fragment
# --
IF 1 = 1
BEGIN
    $0
END
#+end_src

**** [ex] Exists

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ex.yasnippet
# name: EXISTS fragment
# --
EXISTS
#+end_src

**** [nex] Not Exists

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/nex.yasnippet
# name: NOT EXISTS fragment
# --
NOT EXISTS
#+end_src

**** If Exists

Perform an operation if a selected object exists.

#+begin_src sql :tangle no
# name: ...
# --
IF EXISTS(
 SELECT
 FROM ${1:object})
 BEGIN
    $0
 END
#+end_src

**** Case

#+begin_src sql :tangle no
CASE /*expression*/
    WHEN /*expression*/ THEN /*result_expression*/
    WHEN /*expression*/ THEN /*result_expression*/
    ELSE /*result_expression*/
END
#+end_src

**** [cte] Common Table Expression

Temporary inline view.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/cte.yasnippet
# name: WITH cte fragment
# --
;WITH ${1:cte_name} AS
(
    -- SELECT
    -- FROM
    -- GROUP BY
)
-- Statement that executes the common table expression
SELECT $0
FROM $1;
go
#+end_src

**** [wtf] What The Fuck

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/wtf.yasnippet
# name: WTF fragment
# --
WTF???!??!  AAAAAARRRRRRRRRRGGGGGGGGHHHHHHHHHHHHHHHHHHH!!!!!!!!!!!!!!!!!!
#+end_src

*** Function

Naming convention: functions are prefixed with ~ufn~.

**** [ctif] Create Inline Table Function

Creates an inline table function.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/citf.yasnippet
# name: Create inline table-va...
# --
IF OBJECT_ID (N'${1:[schema].[inline_function_name]}', N'IF') IS NOT NULL
    DROP FUNCTION $1;
go

-- ================================================
SET ANSI_NULLS ON
go
SET QUOTED_IDENTIFIER ON
go
-- =============================================
-- Author:      /* Author */
-- Create date: /* Create Date */
-- Description: /* Description */
-- =============================================
CREATE FUNCTION $1 (@${2:parameter_name} ${3:parameter_data_type})
RETURNS TABLE
--WITH ENCRYPTION|SCHEMABINDING, ...
AS
RETURN
(
    -- Add the SELECT statement with parameter references here
    SELECT @$2 AS c1
    $0
);
go

-- =============================================
-- Example to execute function
-- =============================================
SELECT *
FROM $1 /* owner.inline_function_name */
    (/* value_for_@parameter_name */)
go
#+end_src

**** [ctf] Create Multi-Statement Table Function

Creates a multi-statement table function.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ctf.yasnippet
# name: Create multi-stateme...
# --
IF OBJECT_ID (N'${1:[schema].[table_function_name]}', N'TF') IS NOT NULL
    DROP FUNCTION $1;
go

CREATE FUNCTION $1 (@{2:parameter_name} ${3:parameter_data_type})
RETURNS @${4:return_variable_name} TABLE
(
    /* table type definition */
    $2 $3
)
--WITH ENCRYPTION|SCHEMABINDING, ...
AS
BEGIN
    /* function body */
    INSERT @$4
    SELECT 1
    RETURN
END;
go

-- =============================================
-- Example to execute function
-- =============================================
SELECT * FROM $1 /* owner.table_function_name */
    (/* value_for_@parameter_name */)
go
#+end_src

**** [csf] Create Scalar Function

Creates a scalar function.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/csf.yasnippet
# name: Create scalar function
# --
IF OBJECT_ID (N'${1:[schema].[scalar_function_name]}', N'FN') IS NOT NULL
    DROP FUNCTION $1;
go

-- =============================================
SET ANSI_NULLS ON
go
SET QUOTED_IDENTIFIER ON
go
-- =============================================
-- Author:      /* Author */
-- Create date: /* Create Date */
-- Description: /* Description */
-- =============================================
CREATE FUNCTION $1 (@{2:parameter_name} ${3:parameter_data_type})
RETURNS ${4:function_data_type}
--WITH ENCRYPTION|SCHEMABINDING, ...
AS
-- Returns ...
BEGIN
    /* function body */
--  eg.
--  DECLARE @v_ret $4
--  SELECT @v_ret = /* scalar expression */
--  RETURN @v_ret$0
END;
go

-- =============================================
-- Example to execute function
-- =============================================
SELECT $1 /* owner.scalar_function_name */
    (/* value_for_@parameter_name */)
go
#+end_src

**** [af] Alter Function

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/af.yasnippet
# name: ALTER FUNCTION fr...
# --
ALTER FUNCTION $0
#+end_src

**** [dfn] Drop Function

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/dfn.yasnippet
# name: Drop function
# --
DROP FUNCTION $0
#+end_src

*** Help

**** [d] Describe object

List or describe database objects. Calls ~sp_help~.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/d.yasnippet
# name: Describe object
# --
EXEC sp_help '${1:object}';
#+end_src

**** [ld] List Databases

List databases.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ld.yasnippet
# name: List Databases
# --
SELECT
    name,
    create_date,
    compatibility_level,
    collation_name
FROM sys.databases
WHERE name LIKE '%%';
#+end_src

A *collation* consists of an enumeration of data and their equivalence to deduce
therefrom the processing behavior of the strings especially in the *comparison*
and *sorting* operations.

- *Code Page --* 1-4 digit number specifying code page.
- *Case Sensitivity --* CS = case sensitive, CI = insensitive.
- *Accent Sensitivity --* AI = accent insensitive, AS = accent sensitive.

Collation ~SQL_Latin1_General_CP1_CI_AI~:

- CP1 = Code Page 1252, that is Latin(ANSI).
- Case-Insensitive.
- Accent-Insensitive.

**** [lf] List Functions

List functions.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/lf.yasnippet
# name: List Functions
# --
SELECT
    name,
    definition,
    type_desc,
    type
FROM sys.sql_modules m
INNER JOIN sys.objects o
    ON m.object_id = o.object_id
WHERE type IN ('FN', 'IF', 'TF');
#+end_src

**** [li] List Indexes

List indexes.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/li.yasnippet
# name: List Indexes
# --
SELECT
    t.name                              AS TableName,
    i.name                              AS IndexName,
    col.name                            AS ColumnName,
    i.index_id                          AS IndexId,
    ic.index_column_id                  AS ColumnId
FROM sys.indexes                        i
INNER JOIN sys.index_columns            ic
    ON i.object_id = ic.object_id AND i.index_id = ic.index_id
INNER JOIN sys.columns                  col
    ON ic.object_id = col.object_id AND ic.column_id = col.column_id
INNER JOIN sys.tables                   t
    ON i.object_id = t.object_id
WHERE /* i.is_primary_key = 0
    AND i.is_unique = 0
    AND i.is_unique_constraint = 0
    AND */ t.is_ms_shipped = 0
    AND i.name LIKE '%%'                -- Index name.
ORDER BY
    t.name,
    i.name,
    i.index_id,
    ic.index_column_id;
#+end_src

*Comma-separated list* of index columns:

#+begin_src sql :tangle no
-- List Indexes (for SQL Server).  Idem as above, with columns concatenated per index.
SELECT
    -- SCHEMA_NAME(t.schema_id)            AS "schema",
    t.name                              AS table_name,
    i.name                              AS index_name,
    SUBSTRING(column_names, 1, LEN(column_names) - 1) AS columns,
    CASE
        WHEN i.type = 1                 THEN 'Clustered index'
        WHEN i.type = 2                 THEN 'Nonclustered unique index'
        WHEN i.type = 3                 THEN 'XML index'
        WHEN i.type = 4                 THEN 'Spatial index'
        WHEN i.type = 5                 THEN 'Clustered columnstore index'
        WHEN i.type = 6                 THEN 'Nonclustered columnstore index'
        WHEN i.type = 7                 THEN 'Nonclustered hash index'
    END                                 AS index_type,
    CASE
        WHEN i.is_unique = 1            THEN 'Unique'
                                        ELSE 'Not unique'
    END                                 AS "unique"
FROM sys.objects                        t
INNER JOIN sys.indexes                  i
    ON t.object_id = i.object_id
CROSS APPLY
(
    SELECT col.name + ', '
    FROM sys.index_columns              ic
    INNER JOIN sys.columns              col
        ON ic.object_id = col.object_id AND ic.column_id = col.column_id
    WHERE ic.object_id = t.object_id
        AND ic.index_id = i.index_id
    ORDER BY index_column_id
    FOR XML PATH('')
)                                       D(column_names)
WHERE t.is_ms_shipped = 0
    AND index_id > 0
    AND t.name LIKE '%%'                -- Table name.
    AND i.name LIKE '%%'                -- Index name.
ORDER BY
    t.name,
    i.name;
#+end_src

#+begin_src sql :tangle no
-- List Indexes (for Oracle).
SELECT
    ind.owner                           AS INDEX_OWNER,
    ind.table_name,
    ind.index_name,
    ind_col.column_name,
    ind_col.column_position,
    ind.uniqueness
FROM sys.all_indexes                    ind
INNER JOIN sys.all_ind_columns          ind_col
    ON ind.owner = ind_col.index_owner
        AND ind.index_name = ind_col.index_name
WHERE
    -- Exclude (some) Oracle default schemas.
    ind.owner NOT IN ('APEX_040200', 'CTXSYS', 'LBACSYS', 'MDSYS', 'OLAPSYS',
                      'ORDDATA', 'ORDSYS', 'SYS', 'SYSTEM', 'WMSYS', 'XDB')
    AND ind.index_name LIKE UPPER('%%')
ORDER BY
    ind.table_owner,
    ind.table_name,
    ind.index_name,
    ind_col.column_position;
#+end_src

Comma-separated list of index columns:

#+begin_src sql :tangle no
-- List Indexes (for Oracle).  Idem as above, with columns concatenated per index.
SELECT
    aic.index_owner,
    aic.table_name,
    aic.index_name,
    LISTAGG(aic.column_name, ', ')
        WITHIN GROUP (ORDER BY aic.column_position) AS COLS
FROM all_ind_columns                    aic
WHERE
    -- Exclude (some) Oracle default schemas.
    aic.index_owner NOT IN ('APEX_040200', 'CTXSYS', 'LBACSYS', 'MDSYS', 'OLAPSYS',
                            'ORDDATA', 'ORDSYS', 'SYS', 'SYSTEM', 'WMSYS', 'XDB')
    AND aic.table_name LIKE UPPER('%%')
    AND aic.index_name LIKE UPPER('%%')
GROUP BY
    aic.index_owner,
    aic.table_name,
    aic.index_name
ORDER BY
    aic.index_owner,
    aic.table_name,
    aic.index_name;
#+end_src

**** List missing indexes (improve the performance of databases via indexes)

In high-usage environments, one of the main performance bottlenecks that can
start to appear is the speed at which the database is able to run the many SQL
queries.

The below SQL script is designed to help identifying ways to *increase
performance in MSSQL-database environments* based on the most commonly-run
queries in that environment.

It analyzes the recent queries that have been run, and suggests database indexes
that could be added in order to speed them up.  The number of recent queries it
checks can be increased or decreased by modifying the initial ~SELECT~ statement
at the start of the script.  Aside from just straight *re-building primary key
indexes*, this is the best tool we've seen for *speeding up performance* in SQL
Server queries, *from minutes down to seconds*.

For maximum effectiveness, this SQL script should be run on an actual production
environment's database, so that it can best detect what the most common SQL
queries are for that database.

#+begin_warning
Each database has different volumes of data on each table in their environment,
and *adding too many indexes to a database can drastically reduce its
performance*.  Hence, a DBA should look at the use cases for an environment and
what tables those uses cases cover, and figure out effective indexes to put on
the database.
#+end_warning

#+begin_src sql :tangle no
-- performance_script. For SQL Server.
SELECT TOP 25
    -- An estimate of the overall value of this index.
    CAST(user_seeks * avg_total_user_cost * (avg_user_impact * 0.01) AS INT) AS [index_advantage],
    -- The last time another seek was added to this row.
    migs.last_user_seek,
    mid.[statement]                     AS [Database.Schema.Table],
    -- Columns that were part of an exact comparison.
    mid.equality_columns,
    -- Columns that were part on any other comparison including <, >, <>, or BETWEEN.
    mid.inequality_columns,
    -- Columns return, but not part of a comparison.
    mid.included_columns,
    -- Number of times this index would have been used if it had existed.
    migs.user_seeks,
    -- Cost of query without the index.
    migs.avg_total_user_cost,
    -- Estimated improvment of previous column cost if this index is created.
    migs.avg_user_impact,
    'CREATE INDEX IX_' + LEFT(RIGHT(mid.STATEMENT, CHARINDEX('[', REVERSE(mid.[statement]))-1), LEN(RIGHT(mid.STATEMENT, CHARINDEX('[', REVERSE(mid.[statement]))-1))-1) + '_'
    + CASE
          WHEN mid.inequality_columns IS NULL THEN REPLACE(REPLACE(REPLACE(mid.equality_columns, ', ', '_'), '[', ''), ']', '')
          WHEN mid.equality_columns IS NULL THEN REPLACE(REPLACE(REPLACE(mid.inequality_columns, ', ', '_'), '[', ''), ']', '')
          ELSE REPLACE(REPLACE(REPLACE(mid.equality_columns, ', ', '_'), '[', ''), ']', '') + '_' + REPLACE(REPLACE(REPLACE(mid.inequality_columns, ', ', '_'), '[', ''), ']', '')
      END + ' ON ' + mid.STATEMENT + ' ('
    + CASE
          WHEN mid.inequality_columns IS NULL THEN mid.equality_columns
          WHEN mid.equality_columns IS NULL THEN mid.inequality_columns
          ELSE mid.equality_columns + ', ' + mid.inequality_columns
      END + ')'
    + CASE
          WHEN ISNULL(mid.included_columns, '') <> '' THEN ' INCLUDE (' + mid.included_columns + ')'
          ELSE ''
      END                               AS CREATE_STATEMENT
FROM sys.dm_db_missing_index_group_stats migs
INNER JOIN sys.dm_db_missing_index_groups mig
    ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details mid
    ON mig.index_handle = mid.index_handle
WHERE mid.database_id = DB_ID()
ORDER BY index_advantage DESC;
#+end_src

Script to create missing indexes on all FK columns.  (*WARNING --* For performance
reason, not all FK need to be indexed!)

#+begin_src sql :tangle no
-- For Oracle.
-- BUG: Does not handle properly index names on multiple columns.
SELECT 'CREATE INDEX ' || fk.table_name || '_' || columns || ' on ' || fk.table_name || '(' || columns || ');' SQL_QUERY
   -- TABLESPACE afm_ndx; ' --,
    ,all_tables.num_rows
   --    , fk.*
FROM (SELECT DECODE (b.table_name, NULL, '<missing>', 'ok') status,
             a.table_name,
             a.columns,
             b.columns col_index
      FROM (SELECT substr (a.table_name, 1, 30) table_name,
                   substr (a.constraint_name, 1, 30) constraint_name,
                   MAX (DECODE (position, 1,          substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (position, 2,  ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (position, 3,  ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (position, 4,  ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (position, 5,  ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (position, 6,  ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (position, 7,  ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (position, 8,  ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (position, 9,  ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (position, 10, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (position, 11, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (position, 12, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (position, 13, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (position, 14, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (position, 15, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (position, 16, ', ' || substr (column_name, 1, 30), NULL)) columns
            FROM user_cons_columns a,
                 user_constraints b
            WHERE a.constraint_name = b.constraint_name AND b.constraint_type = 'R'
            GROUP BY substr (a.table_name, 1, 30),
                     substr (a.constraint_name, 1, 30)
           ) a,
           (SELECT substr (table_name, 1, 30) table_name,
                   substr (index_name, 1, 30) index_name,
                   MAX (DECODE (column_position,  1,         substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (column_position,  2, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (column_position,  3, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (column_position,  4, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (column_position,  5, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (column_position,  6, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (column_position,  7, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (column_position,  8, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (column_position,  9, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (column_position, 10, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (column_position, 11, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (column_position, 12, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (column_position, 13, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (column_position, 14, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (column_position, 15, ', ' || substr (column_name, 1, 30), NULL)) ||
                   MAX (DECODE (column_position, 16, ', ' || substr (column_name, 1, 30), NULL)) columns
            FROM user_ind_columns
            GROUP BY substr (table_name, 1, 30),
                     substr (index_name, 1, 30)
           ) b
      WHERE a.table_name = b.table_name (+) AND b.columns (+) LIKE a.columns || '%'
     ) fk,
     all_tables
WHERE fk.table_name = all_tables.table_name
  AND fk.table_name LIKE UPPER('%%')
  AND fk.status = '<missing>'
  AND num_rows != 0
ORDER BY fk.table_name;
#+end_src

**** List redundant indexes

https://dzone.com/articles/how-to-find-redundant-indexes-in-sql

Don't apply this advice in read-heavy, write-rarely databases.

#+begin_src sql :tangle no
-- For SQL Server.
WITH i
AS
(
    SELECT
        t.name AS table_name,
        i.name AS index_name,
        c.name AS column_name,
        ic.index_column_id
    FROM sys.indexes                    i
    JOIN sys.index_columns              ic
        ON i.object_id = ic.object_id AND i.index_id = ic.index_id
    JOIN sys.columns                    c
        ON ic.object_id = c.object_id AND ic.column_id = c.column_id
    JOIN sys.tables                     t
        ON i.object_id = t.object_id
),

indexes
AS
(
    SELECT
        table_name,
        index_name,
        STUFF((
                  SELECT ',' + j.column_name
                  FROM i j
                  WHERE i.table_name = j.table_name
                        AND i.index_name = j.index_name
                  FOR XML PATH('')      -- Yay, XML in SQL!
              ), 1, 1, '')              AS columns
    FROM i
    GROUP BY
        table_name,
        index_name
)

SELECT
    i.table_name,
    i.index_name                        AS "Deletion candidate index",
    i.columns                           AS "Deletion candidate columns",
    j.index_name                        AS "Existing index",
    j.columns                           AS "Existing columns"
FROM indexes                            i
JOIN indexes                            j
    ON i.table_name = j.table_name AND j.columns LIKE i.columns + ',%';
#+end_src

#+begin_src sql :tangle no
-- For Oracle.
WITH indexes
AS
(
    SELECT
        i.index_name,
        i.table_name,
        LISTAGG(c.column_name, ', ')
            WITHIN GROUP (ORDER BY c.column_position) AS columns
    FROM all_indexes                    i
         JOIN all_ind_columns c ON i.index_name = c.index_name
    GROUP BY
        i.table_name,
        i.index_name,
        i.leaf_blocks
)

SELECT
    i.table_name,
    i.index_name                        AS "Deletion candidate index",
    i.columns                           AS "Deletion candidate columns",
    j.index_name                        AS "Existing index",
    j.columns                           AS "Existing columns"
FROM indexes                            i
JOIN indexes                            j
    ON i.table_name = j.table_name AND j.columns LIKE i.columns || ',%';
#+end_src

**** List unused indexes

#+begin_src sql :tangle no
USE MASTER;
GO
GRANT VIEW SERVER STATE TO afm;
#+end_src

#+begin_src sql :tangle no
SELECT
    OBJECT_NAME(s.object_id)            AS table_name,
    i.name                              AS index_name,
    i.index_id,
    user_seeks + user_scans + user_lookups AS reads,
    user_updates                        AS writes,
    SUM(p.rows)                         AS rows,
    last_user_update
FROM sys.dm_db_index_usage_stats        s
JOIN sys.indexes                        i
    ON s.object_id = i.object_id AND i.index_id = s.index_id
JOIN sys.partitions                     p
    ON s.object_id = p.object_id AND p.index_id = s.index_id
WHERE OBJECTPROPERTY(s.object_id, 'IsUserTable') = 1
    AND s.index_id > 0
    AND s.database_id = DB_ID() -- Database ID of the current database.
    AND user_seeks + user_scans + user_lookups = 0
GROUP BY
    OBJECT_NAME(s.object_id),
    i.name,
    i.index_id,
    user_seeks + user_scans + user_lookups,
    user_updates,
    last_user_update
ORDER BY
    writes DESC,
    reads ASC;
#+end_src

If you see indexes where:

- there are no seeks, scans or lookups, but
- there are updates,

this means that SQL Server has not used the index to satisfy a query but still
needs to maintain the index.

#+begin_tip
Remember that the data from these DMVs is reset when SQL Server is restarted, so
make sure you have collected data for a long enough period of time to determine
which indexes may be good candidates to be dropped.
#+end_tip

**** [ll] List Logins

List logins and associated roles.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ll.yasnippet
# name: List Logins
# --
SELECT
    name,
    type_desc,
    default_database_name,
    type,
    create_date
FROM sys.server_principals
WHERE type_desc = 'SQL_LOGIN'
    AND name LIKE '%%'
ORDER BY name;
#+end_src

**** [ls] List Schemas

List schemas.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ls.yasnippet
# name: List Schemas
# --
SELECT
    name,
    schema_id,
    principal_id
FROM sys.schemas
WHERE name LIKE '%%'
#+end_src

**** [lt] List Tables

List tables.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/lt.yasnippet
# name: List Tables
# --
SELECT
    TABLE_CATALOG,
    TABLE_SCHEMA,
    TABLE_NAME,
    TABLE_TYPE
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_TYPE = 'BASE TABLE'
    AND TABLE_NAME LIKE '%%';
#+end_src

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ltora.yasnippet
-- For Oracle.
SELECT DISTINCT
    OWNER,
    OBJECT_NAME,
    OBJECT_TYPE
FROM ALL_OBJECTS
WHERE OBJECT_TYPE = 'TABLE'
    AND OWNER LIKE '%%'
    AND OBJECT_NAME LIKE '%%';
#+end_src

**** List Columns (xss, afm-fields, for all the fields in the SQL Database Schema)

#+begin_src sql :tangle no
SELECT
    sys.objects.name                    AS TABLE_NAME,
    sys.columns.name                    AS COLUMN_NAME
FROM sys.objects
LEFT OUTER JOIN sys.columns
    ON sys.objects.object_id = sys.columns.object_id
WHERE type = 'U'
    -- AND sys.objects.name LIKE 'int_%' -- Table name.
ORDER BY sys.objects.name, sys.columns.name;
#+end_src

#+begin_note
In SQL Server, column aliases should use brackets as using single quotes is
deprecated (not to mention easily confused with string literals).

But the only portable notation is using double quotes...
#+end_note

XXX Add referenced table but avoid duplicates (multi-columns FK)

#+begin_src sql :tangle no
-- xss. For SQL Server.
SELECT
    OBJECT_NAME(c.object_id)            AS TABLE_NAME,
    c.name                              AS COLUMN_NAME,
    CASE i.is_primary_key
        WHEN 1 THEN '!'
        ELSE ''
    END                                 AS PRIMARY_KEY,
    CASE c.is_nullable
        WHEN 0 THEN '*'
        ELSE ''
    END                                 AS REQUIRED,
    t.name                              AS DATA_TYPE,
    CASE
        WHEN t.name IN ('char', 'varchar', 'nvarchar', 'decimal') THEN c.max_length
        ELSE NULL
    END                                 AS "SIZE",
    CASE
        WHEN c.default_object_id = 0 OR OBJECT_DEFINITION(c.default_object_id) = '(NULL)' THEN ''
        ELSE OBJECT_DEFINITION(c.default_object_id)
    END                                 AS DEFAULT,
    CASE c.is_identity
        WHEN 1 THEN 'IDENTITY'
        ELSE ''
    END                                 AS IS_IDENTITY
    -- XXX Add referenced table.
    -- ,CASE
    --     WHEN fk.name IS NOT NULL THEN '=> ' + OBJECT_NAME(fk.object_id) + '.' + fk.name
    --     ELSE ''
    -- END                                 AS Foreign_Key
FROM sys.columns                        c
INNER JOIN sys.objects                  o
    ON (o.object_id = c.object_id
        AND type IN ('U','V'))          -- User Tables and Views. XXX Test it!
INNER JOIN sys.types                    t
    ON c.user_type_id = t.user_type_id
-- Remove the duplicate results (because some tables have more than one index
-- with the same leading key column) by applying a filter in the JOIN to
-- sys.indexes to only return the primary keys).
-- https://stackoverflow.com/questions/21759295/get-list-of-all-columns-with-complete-details-identity-nullabel-primary-key-i
LEFT OUTER JOIN (sys.index_columns      ic
                INNER JOIN sys.indexes  i
                    ON ic.object_id = i.object_id AND ic.index_id = i.index_id
                    AND i.is_primary_key = 1)
    ON ic.object_id = c.object_id AND ic.column_id = c.column_id
-- LEFT JOIN sys.foreign_key_columns    fkc
--     ON fkc.parent_object_id = c.object_id AND fkc.parent_column_id = c.column_id
-- LEFT JOIN sys.columns                fk
--     ON fk.object_id = fkc.referenced_object_id AND fk.column_id = fkc.referenced_column_id
WHERE
    OBJECT_NAME(c.object_id) LIKE '%%'  -- Table name.
    AND c.name LIKE '%%'                -- Column name.
    -- AND fk.name LIKE '%%'            -- Foreign column name.  (Limit to FK constraints only.)
ORDER BY
    OBJECT_NAME(c.object_id),
    c.name;
#+end_src

#+begin_note
Join to *user* ~_type_id~ in the ~sys.types~ table.  ~user_type_id~ is identical to
~system_type_id~ for system types -- See
https://msdn.microsoft.com/en-gb/library/ms188021.aspx
#+end_note

#+begin_src sql :tangle no
-- For Oracle.
SELECT
    table_name,
    column_name,
    nullable,
    data_type,
    char_length,
    data_default,
    identity_column
FROM user_tab_cols
WHERE
    table_name LIKE UPPER('%%')
    AND column_name LIKE UPPER('%%')
ORDER BY
    table_name,
    column_name;
#+end_src

**** [lv] List Views

List views.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/lv.yasnippet
# name: List Views
# --
SELECT
    table_catalog AS catalog,
    TABLE_SCHEMA AS schema_name,
    TABLE_NAME AS view_name
FROM INFORMATION_SCHEMA.VIEWS
WHERE TABLE_NAME LIKE '%%';
#+end_src

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/lvora.yasnippet
# name: List Views (for Oracle)
# --
SELECT
    owner,
    view_name
FROM sys.all_views
WHERE
    -- Exclude (some) Oracle default schemas.
    owner NOT IN ('APEX_040200', 'CTXSYS', 'LBACSYS', 'MDSYS', 'OLAPSYS',
                  'ORDDATA', 'ORDSYS', 'SYS', 'SYSTEM', 'WMSYS', 'XDB')
    AND view_name LIKE UPPER('%%')
ORDER BY
    owner,
    view_name;
#+end_src

#+begin_src sql
SELECT view_name, text
FROM user_views
WHERE view_name LIKE UPPER('%%');
#+end_src

**** [sf] Show Function

Show a function's definition.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/sf.yasnippet
# name: Show Function
# --
SELECT OBJECT_DEFINITION(OBJECT_ID('${1:funcname}'));
#+end_src

**** [sis] Search In Sources

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/sis.yasnippet
# name: Search In Sources
# --
/*
This is an easy way to look through the sources of all objects in the database
if you need to find particular string. This script can be used, for example,
to find references of some specific object by other objects. Depending on the
size of your database you might want to limit the search scope to particular
object type. Just comment unneeded object types in WHERE statement.
Enter search string between %% marks in @SearchPattern initialisation statement.
When you get the results you can copy object name from "FullName" column and
use SSMSBoost to quickly locate it in the object explorer, or you can continue
searching in results using "Find in ResultsGrid" function.

This script is provided to you by SSMSBoost as is. Improvements and comments are welcome.
Redistribution with reference to SSMSBoost project website is welcome.
SSMSBoost team, 2014
*/
DECLARE @SearchPattern NVARCHAR(128)

SET @SearchPattern = '%$0%'

SELECT
    SCHEMA_NAME(o.schema_id) AS [schema],
    o.[name],
    o.type,
    '[' + SCHEMA_NAME(o.schema_id) + '].[' + o.[name] + ']' AS [FullName],
    OBJECT_DEFINITION(object_id) AS [Source]
FROM sys.objects AS o
WHERE LOWER(OBJECT_DEFINITION(o.object_id)) LIKE LOWER(@SearchPattern)
    AND o.type IN (
    'C', --- = Check constraint
    'D', --- = Default (constraint or stand-alone)
    'P', --- = SQL stored procedure
    'FN', --- = SQL scalar function
    'R', --- = Rule
    'RF', --- = Replication filter procedure
    'TR', --- = SQL trigger (schema-scoped DML trigger, or DDL trigger at either the database or server scope)
    'IF', --- = SQL inline table-valued function
    'TF', --- = SQL table-valued function
    'V') --- = View
UNION ALL
SELECT
    SCHEMA_NAME(q.schema_id) AS [schema],
    q.[name],
    'SQ' AS type,
    '[' + SCHEMA_NAME(q.schema_id) + '].[' + q.[name] + ']' AS [FullName],
    activation_procedure AS [Source]
FROM sys.service_queues q
WHERE q.activation_procedure LIKE LOWER(@SearchPattern)
ORDER BY
    o.type,
    o.[name];
#+end_src

*** Index

**** [crunq] Create Unique Index

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/crunq.yasnippet
# name: Create unique index
# --
CREATE UNIQUE INDEX unq_$0
ON
#+end_src

**** [cni] Create Non-Clustered Index (crnci)

Creates a basic, non-clustered index.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/cni.yasnippet
# name: Create non-unique n...
# --
IF EXISTS (SELECT name FROM sys.indexes WHERE name = N'nci_${3:index_name}')
    DROP INDEX nci_$3 ON ${1:[schema].[owner_name]};
go

CREATE NONCLUSTERED INDEX nci_$3
ON $1 (${2:column})
--WITH PAD_INDEX
--    | FILLFACTOR = fillfactor
--    | IGNORE_DUP_KEY
--    | DROP_EXISTING
--    | STATISTICS_NORECOMPUTE
--    | SORT_IN_TEMPDB, .. as required
-- ON filegroup
go
$0
#+end_src

**** [cuni] Create Unique Non-Clustered Index

Creates a unique, non-clustered index.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/cuni.yasnippet
# name: Create unique nonclu...
# --
IF EXISTS (SELECT name FROM sys.indexes WHERE name = N'unq_${3:index_name}')
    DROP INDEX unq_$3 ON ${1:[schema].[owner_name]};
go

CREATE UNIQUE NONCLUSTERED INDEX unq_$3
ON $1 (${2:column})
--WITH
--    PAD_INDEX,
--    FILLFACTOR = fillfactor,
--    IGNORE_DUP_KEY,
--    DROP_EXISTING = OFF,
--    STATISTICS_NORECOMPUTE,
--    SORT_IN_TEMPDB = OFF, .. as required
ON ${4:filegroup_name}
go
$0
#+end_src

**** [cci] Create Clustered Index (crci)

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/cci.yasnippet
# name: Create non-unique cl...
# --
IF EXISTS (SELECT name FROM sys.indexes WHERE name = N'ci_${3:index_name}')
    DROP INDEX ci_$3 ON ${1:[schema].[owner_name]};
go

CREATE CLUSTERED INDEX ci_$3
ON $1 (${2:column})
--WITH PAD_INDEX
--    | FILLFACTOR = fillfactor
--    | IGNORE_DUP_KEY
--    | DROP_EXISTING
--    | STATISTICS_NORECOMPUTE
--    | SORT_IN_TEMPDB, .. as required
-- ON filegroup
go
$0
#+end_src

**** [cuci] Create Unique Clustered Index

Create index full syntax.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/cuci.yasnippet
# name: Create unique cluster...
# --
IF EXISTS (SELECT name FROM sys.indexes WHERE name = N'unq_${3:index_name}')
    DROP INDEX unq_$3 ON ${1:[schema].[owner_name]};
go

CREATE UNIQUE CLUSTERED INDEX unq_$3
ON $1 (${2:column})
WITH
PAD_INDEX,
FILLFACTOR = ${5:fillfactor_value},
IGNORE_DUP_KEY,
DROP_EXISTING,
STATISTICS_NORECOMPUTE
--    | SORT_IN_TEMPDB, .. as required
ON ${4:filegroup_name}
go
$0
#+end_src

**** [di] Drop Index

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/di.yasnippet
# name: Drop index
# --
DROP INDEX $0
#+end_src

*** Join fragment

**** [j] Join

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/j.yasnippet
# name: JOIN fragment
# --
JOIN $0
#+end_src

**** [cj] Cross Join

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/cj.yasnippet
# name: CROSS JOIN fragment
# --
CROSS JOIN $0
#+end_src

**** [fj] Full Join

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/fj.yasnippet
# name: FULL JOIN fragment
# --
FULL JOIN $0
#+end_src

**** [foj] Full Outer Join

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/foj.yasnippet
# name: FULL OUTER JOIN fr...
# --
FULL OUTER JOIN $0
#+end_src

**** [ij] Inner Join

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ij.yasnippet
# name: INNER JOIN fragment
# --
INNER JOIN $0
#+end_src

**** [j] Join

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/j.yasnippet
# name: JOIN fragment
# --
JOIN $0
#+end_src

**** [lj] Left Join

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/lj.yasnippet
# name: LEFT JOIN fragment
# --
LEFT JOIN $0
#+end_src

**** [loj] Left Outer Join

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/loj.yasnippet
# name: LEFT OUTER JOIN fr...
# --
LEFT OUTER JOIN $0
#+end_src

**** [rj] Right Join

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/rj.yasnippet
# name: RIGHT JOIN fragment
# --
RIGHT JOIN $0
#+end_src

**** [roj] Right Outer Join

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/roj.yasnippet
# name: RIGHT OUTER JOIN f...
# --
RIGHT OUTER JOIN $0
#+end_src

*** Login

**** [cl] Create SQL Authentication Login

Creates a SQL Server Authentication login.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/cl.yasnippet
# name: CREATE SQL Server l...
# --
CREATE LOGIN ${1:SQL_login_name}
WITH PASSWORD = N'${2:Strong_P@ssword}'$0 /* HASHED */ /* MUST_CHANGE */
--  DEFAULT_DATABASE = database
--  DEFAULT_LANGUAGE = language
--  CHECK_POLICY = ON | OFF
--  SID = sid
--  CHECK_EXPIRATION = ON | OFF
--  CREDENTIAL = credential_name
go
#+end_src

**** Create Windows Authentication Login

Creates a Windows Authentication login.

#+begin_src sql :tangle no
# name: CREATE Windows l...
# --
CREATE LOGIN ${1:[domain_name\user_name]}
FROM WINDOWS$0
WITH
DEFAULT_DATABASE = ${2:default_database}
--  DEFAULT_LANGUAGE = language
--  CERTIFICATE certificate_name
--  ASYMMETRIC KEY key_name
go
#+end_src

**** [dl] Drop Login

Drop login.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/dl.yasnippet
# name: Drop login
# --
DROP LOGIN ${1:SQL_login_name}
go
#+end_src

*** Role

**** Create Role

Create Database Role.

#+begin_src sql :tangle no
USE ${1:database_name}
go

CREATE ROLE ${2:role_name}$0
go
#+end_src

*** Schema

**** Create Schema

Create a database schema.

#+begin_src sql :tangle no
CREATE SCHEMA ${1:schema}$0
#+end_src

*** Set options

**** [san] Set ANSI_NULLS

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/san.yasnippet
# name: Change the current A...
# --
SET ANSI_NULLS ON$0
#+end_src

**** [sqi] Set QUOTED_IDENTIFIER

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/sqi.yasnippet
# name: Change the current ...
# --
SET QUOTED_IDENTIFIER ON$0
#+end_src

**** [sxa] Set XACT_ABORT

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/sxa.yasnippet
# name: Change the current X...
# --
SET XACT_ABORT OFF$0
#+end_src

*** Stored Procedure

Naming convention: stored procedures are prefixed with ~usp~.

**** [cp] Create Procedure Basic Template

Create a simple stored procedure with output parameter.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/cp.yasnippet
# name: Create stored proced...
# --
-- Drop stored procedure if it already exists
IF OBJECT_ID ('${1:[schema].[procedure_name]}', 'P') IS NOT NULL
    DROP PROCEDURE $1;
go

-- =============================================
SET ANSI_NULLS ON
go
SET QUOTED_IDENTIFIER ON
go
-- =============================================
-- Author:      /* Author */
-- Create date: /* Create Date */
-- Description: /* Description */
-- =============================================
CREATE PROCEDURE $1
    -- Add the parameters for the function here
    @${2:parameter_name_1} ${3:parameter_data_type_1} = ${4:default_value_for_parameter_1}
    @${5:parameter_name_2} ${6:parameter_data_type_2} OUTPUT
-- WITH ENCRYPTION, RECOMPILE, EXECUTE AS CALLER|SELF|OWNER| 'user_name'
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

    -- Insert statements for procedure here
    SELECT @$2$0
END
go

--SET QUOTED_IDENTIFIER ON|OFF
--SET ANSI_NULLS ON|OFF
--go

-- =============================================
-- Example to execute the stored procedure
-- =============================================
DECLARE @${7:variable_for_output_parameter} $6

EXECUTE $1 /* value_for_parameter_1 */, $7 OUTPUT

SELECT $7
go
#+end_src

**** [crlp] Create CLR Procedure

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/clrp.yasnippet
# name: Create CLR stored pr...
# --
--SET QUOTED_IDENTIFIER ON|OFF
--SET ANSI_NULLS ON|OFF
--go

CREATE PROCEDURE ${1:[schema].[procedure_name]}
(
    @${2:parameter_name} ${3:parameter_data_type}
)
-- WITH EXECUTE AS CALLER|SELF|OWNER| 'user_name'
AS EXTERNAL NAME ${4:[assembly].[class].[method]};
go

--SET QUOTED_IDENTIFIER ON|OFF
--SET ANSI_NULLS ON|OFF
--go$0
#+end_src

**** [ap] Alter Procedure

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ap.yasnippet
# name: ALTER PROCEDURE
# --
ALTER PROCEDURE $0
#+end_src

**** [dp] Drop Procedure

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/dp.yasnippet
# name: Drop stored procedure
# --
DROP PROCEDURE $0
#+end_src

*** Synonym

**** Create Synonym

Creates a synonym.

#+begin_src sql :tangle no
CREATE SYNONYM ${1:[schema].[synonym_name]}
FOR ${2:[schema].[object_name]};
go$0
#+end_src

*** Table

**** [ct] Create Table (crt)

Creates a table (and drop previous one with the same name).

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ct.yasnippet
# name: Create table
# --
IF OBJECT_ID ('${1:[schema].[table_name]}', 'U') IS NOT NULL
    DROP TABLE $1;
go

CREATE TABLE $1
(
    ${2:column_1} ${3:data_type_1} ${4:column_nullability_1},
    ${5:column_2} ${6:data_type_2} ${5:column_nullability_2},$0
    CONSTRAINT /* contraint_name */ PRIMARY KEY (/* columns_in_primary_key */)
);
go
#+end_src

**** [ctt] Create Temporary Table (crtt)

Creates a temporary table.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ctt.yasnippet
# name: Create temp table
# --
CREATE TABLE #temp
(
    $0
);
go
#+end_src

**** [ctv] Create Table Variable (crtv)

Creates a table variable.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ctv.yasnippet
# name: Create table var
# --
DECLARE @tbl TABLE
(
    $0
)
#+end_src

**** [at] Alter Table fragment

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/at.yasnippet
# name: ALTER TABLE fragm...
# --
ALTER TABLE $0
#+end_src

**** [ata] Add Column

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ata.yasnippet
# name: Add column
# --
-- Add a new column to the table.
ALTER TABLE ${1:[schema].[table_name]}
    ADD [${2:new_column_name}] ${3:data_type} ${4:new_column_nullability};
go$0
#+end_src

**** [atac] Modify Column

#+begin_warning
Running ~ALTER COLUMN~ without mentioning attribute ~NOT NULL~ will result in the
column being changed to *nullable*, if it is already not.
#+end_warning

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/atac.yasnippet
# name: Modify column
# --
-- WARNING: If the column is not nullable, specify attribute NOT NULL.
ALTER TABLE ${1:[schema].[table_name]}
    ALTER COLUMN $0;
go
#+end_src

**** [atd] Drop column

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/atd.yasnippet
# name: Drop column
# --
-- Drop a column from the table.
ALTER TABLE ${1:[schema].[table_name]}
    DROP COLUMN $0;
go
#+end_src

**** [crc] Add Constraint

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/crc.yasnippet
# name: Add constraint
# --
ALTER TABLE ${1:[schema].[table_name]}
    ADD CONSTRAINT ${2:constraint_name};
go
#+end_src

**** [atdc] Drop Constraint

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/atdc.yasnippet
# name: Drop constraint
# --
ALTER TABLE ${1:[schema].[table_name]}
    DROP CONSTRAINT ${2:constraint_name};
go
#+end_src

**** [dt] Drop Table

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/dt.yasnippet
# name: Drop table
# --
IF EXISTS (SELECT *
             FROM sys.tables
             JOIN sys.schemas
               ON sys.tables.schema_id = sys.schemas.schema_id
            WHERE sys.schemas.name = N'${1:schema}'
              AND sys.tables.name = N'${2:table}')
    DROP TABLE $1.$2
go
#+end_src

*** Transaction

**** [bt] Begin Transaction

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/bt.yasnippet
# name: Begin transaction
# --
BEGIN TRANSACTION $0
#+end_src

When opening a new query window, you could specify:

: BEGIN TRAN
:
: ROLLBACK

**** [ctr] Commit Transaction

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ctr.yasnippet
# name: Commit transaction
# --
COMMIT TRANSACTION $0
#+end_src

**** [rt] Rollback Transaction

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/rt.yasnippet
# name: Rollback transaction
# --
ROLLBACK TRANSACTION $0
#+end_src

*** Trigger

**** Create Trigger

Creates a trigger.

#+begin_src sql :tangle no
# name: Create trigger
# --
IF OBJECT_ID ('${1:trigger_name}', 'TR') IS NOT NULL
    DROP TRIGGER $1;
go

-- =============================================
SET ANSI_NULLS ON
go
SET QUOTED_IDENTIFIER ON
go
-- =============================================
-- Author:      /* Author */
-- Create date: /* Create Date */
-- Description: /* Description */
-- =============================================
CREATE TRIGGER $1
ON ${2:[schema].[table_name]}
FOR INSERT, UPDATE, DELETE
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

    -- Insert statements for trigger here
    RAISERROR (50009, 16, 10)
    $0
END;
go
#+end_src

**** Enable Trigger

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/atet.yasnippet
# name: Enable trigger
# --
ALTER TABLE ${1:[schema].[table_name]} ENABLE TRIGGER $0;
#+end_src

**** Enable All Triggers

Enable all triggers on table.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/ateta.yasnippet
# name: Enable all triggers on...
# --
ALTER TABLE ${1:[schema].[table_name]}$0 ENABLE TRIGGER ALL;
go
#+end_src

#+begin_src sql :tangle no
-- Enable all triggers on all tables (For Oracle).
BEGIN
   FOR rec IN (SELECT trigger_name
               FROM user_triggers)
   LOOP
      EXECUTE IMMEDIATE 'ALTER TRIGGER ' || rec.trigger_name || ' ENABLE';
      DBMS_OUTPUT.put_line (
         'Status of ' || rec.trigger_name || ' set to ENABLE'
      );
   END LOOP;
END;
#+end_src

**** Disable Trigger

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/atdt.yasnippet
# name: Disable trigger
# --
ALTER TABLE ${1:[schema].[table_name]} DISABLE TRIGGER $0;
#+end_src

**** Disable All Triggers

Disable all triggers on table.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/atdta.yasnippet
# name: Disable all triggers on...
# --
ALTER TABLE ${1:[schema].[table_name]}$0 DISABLE TRIGGER ALL;
go
#+end_src

*** User

**** [cu] Create User

Creates a database user.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/cu.yasnippet
# name: Create database user
# --
CREATE USER ${1:UserName}$0
FOR /* FROM */ LOGIN /* login_name */
--  CERTIFICATE certificate_name
--  ASYMMETRIC KEY key_name
--  WITHOUT LOGIN
--  WITH DEFAULT_SCHEMA = schema_name
go
#+end_src

**** [du] Drop User

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/du.yasnippet
# name: Drop user
# --
DROP USER ${1:user_name}
go
#+end_src

*** User Defined Data Type

**** Create User-Defined Data Type

Creates a user-defined data type.

#+begin_src sql :tangle no
CREATE TYPE ${1:[schema].[my_data_type]}
FROM ${2:data_type} ${3:column_nullability}
#+end_src

*** User Defined Table Type

**** Create User-Defined Table Type

Creates a user-defined table type.

#+begin_src sql :tangle no
CREATE TYPE ${1:[schema].[my_table_type]} AS TABLE
(
    ${2:column_1} ${3:data_type_1},
    ${4:column_2} ${5:data_type_2}
);
go$0
#+end_src

*** User Defined Type

**** Create User-Defined Type

Creates a CLR integration user-defined type.

#+begin_src sql :tangle no
CREATE TYPE ${1:Utf8String}
EXTERNAL NAME ${2:utf8string}.${3:[Microsoft.Samples.SqlServer.utf8string]};
go$0
#+end_src

*** View

**** [cv] Create View

Creates a view.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/cv.yasnippet
# name: Create view
# --
IF OBJECT_ID ('${1:[schema].[view_name]}', 'V') IS NOT NULL
    DROP VIEW $1;
go

CREATE VIEW $1
--WITH ENCRYPTION, SCHEMABINDING, VIEW_METADATA
AS
    SELECT *
    FROM ${2:[schema].[sample_table]}
    $0
-- WITH CHECK OPTION
go
#+end_src

**** [dv] Drop View

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/dv.yasnippet
# name: Drop view
# --
DROP VIEW $0
#+end_src

*** --- Miscellaneous ---

**** [e] Execute

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/e.yasnippet
# name: EXECUTE fragment
# --
EXECUTE
#+end_src

**** [sph] sp_help

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/sph.yasnippet
# name: Execute sp_help
# --
EXEC sp_help$0
#+end_src

**** [spt] sp_helptext

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/spt.yasnippet
# name: Execute sp_helptext
# --
EXEC sp_helptext$0
#+end_src

**** [xpfd] xp_fixeddrives

Retrieve free space on all fixed drives.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/xpfd.yasnippet
# name: Retrieve free space o...
# --
EXEC master..xp_fixeddrives
#+end_src

**** [w2] Who2

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/w2.yasnippet
# name: Execute sp_who2$0
# --
EXEC sp_who2$0
#+end_src

**** [err] @@ERROR

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/err.yasnippet
# name: @@ERROR function ...
# --
@@ERROR$0
#+end_src

**** [mro] Most Recent Objects

Retrieve 20 most recently created objects.

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/mro.yasnippet
# name: Retrieve 20 most rec...
# --
SELECT TOP 20 [name], type, crdate
FROM sysobjects
ORDER BY crdate DESC
#+end_src

**** Comment

A comment block.

#+begin_src sql :tangle no
/*
 * $0
 */
#+end_src

**** Comment

A multiline comment block.

#+begin_src sql :tangle no
/*******************************************
 * $0
 *******************************************/
#+end_src

** Surround With...

*** [begin] Code Snippet for BEGIN...END block

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/begin.yasnippet
# name: Surround with BEGIN...
# --
BEGIN
`yas-selected-text`
END
#+end_src

*** [if] Code Snippet for IF construct

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/if.yasnippet
# name: Surround with IF...
# --
IF (${1:Condition})
BEGIN
`yas-selected-text`
END
 #+end_src

*** [while] Code Snippet for WHILE loop

#+begin_src sql :tangle .emacs.d/snippets/sql-mode/while.yasnippet
# name: Surround with WHILE...
# --
WHILE (${1:Condition})
BEGIN
`yas-selected-text`
END
 #+end_src

* Tips & Tricks

** For Oracle

- You can't use ~PROMPT~ in PL/SQL blocks, so you need to use ~DBMS_OUTPUT.PUT_LINE~
  instead to display the message.

  Note that you also need to add the ~SET SERVEROUTPUT ON~ command at the
  beginning to enable the display of DBMS output.

* General SQL
:PROPERTIES:
:header-args+: :tangle no
:END:

https://www.red-gate.com/simple-talk/sql/t-sql-programming/ten-common-sql-programming-mistakes/

Some good reading:
- [[https://sqlblog.org/2009/10/11/bad-habits-to-kick-avoiding-the-schema-prefix][Always specify the schema]]
- [[https://sqlblog.org/2008/10/30/my-stored-procedure-best-practices-checklist][Stored Procedure Best Practices]]
- [[https://blogs.sentryone.com/aaronbertrand/bad-habits-revival/][Bad habits to avoid]]

XXX Check out https://dataedo.com/kb/query/sql-server!!! (+ version for Oracle !!!)

- http://codereview.stackexchange.com/!!!

- SQL Fiddle: http://sqlfiddle.com/#!3/e7875/5
  (MS SQL Server, Oracle, etc.)

- http://sqlblog.com/blogs/aaron_bertrand/archive/2008/10/30/my-stored-procedure-best-practices-checklist.aspx

- [[https://blogs.sentryone.com/aaronbertrand/backtobasics-ctes][Common Table Expressions (CTEs)]]

** Data Definition and Manipulation Language

*Data Definition Language (DDL)* statements are responsible for defining the
structure or schema of a database. These statements are used for creating,
modifying, or deleting database objects. Here are some examples of DDL
statements:

- ~CREATE~: used to create objects in the database, such as tables, views,
  indexes, and stored procedures.
- ~ALTER~: used to modify the structure of the database, such as adding,
  modifying, or dropping columns, constraints, or indexes.
- ~DROP~: used to delete objects from the database, such as tables, views, or
  indexes.
- ~RENAME~: used to rename an object in the database, such as a table or a column.

On the other hand, *Data Manipulation Language (DML)* statements are responsible
for managing data within the schema objects. These statements allow you to
retrieve, insert, update, or delete data from tables. Here are some examples of
DML statements:

- ~SELECT~: used to retrieve data from one or more tables in the database.
- ~INSERT~: used to insert data into a table.
- ~UPDATE~: used to modify existing data within a table.
- ~DELETE~: used to delete records from a table.

** Constraints on a view

A normal view is essentially a stored query that doesn't persist any data on
disk. Therefore, it's *not possible to enforce integrity constraints* like check
constraints, foreign keys, or primary keys *on a view* because there is no data to
be constrained.

Even if you use an indexed view, which does materialize data, it still doesn't
allow for the enforcement of constraints.

** Meaning of the prefix N in T-SQL statements

It's declaring the string as ~nvarchar~ data type, rather than ~varchar~.

#+begin_verse
You may have seen Transact-SQL code that passes strings around using an
N prefix. This denotes that the subsequent string is in Unicode (the N actually
stands for National language character set). Which means that you are passing an
NCHAR, NVARCHAR or NTEXT value, as opposed to CHAR, VARCHAR or TEXT.
#+end_verse

To quote from Microsoft:

#+begin_verse
Prefix Unicode character string constants with the letter N. Without the
N prefix, the string is converted to the default code page of the database. *This
default code page may not recognize certain characters.*
#+end_verse

** All fields (for Oracle)

Add an alias for ~bl~ like this:

#+begin_src sql
SELECT bl_id, b.*
FROM bl b
#+end_src

** (In)equality tests

Testing (in)equality of ~a~ and ~b~:

- Equality:

  #+begin_src sql
  (a = b)
  OR (a IS NULL AND b IS NULL)
  #+end_src

- Inequality:

  #+begin_src sql
  (a <> b)
  OR (a IS NULL AND b IS NOT NULL)
  OR (a IS NOT NULL AND b IS NULL)

  -- = ISNULL(a, ' ') <> ISNULL(b, ' ')?
  -- Je pense que ce n'est pas équivalent, sauf si a et b ne peuvent jamais valoir ' '...
  #+end_src

About NULL:
- https://www.xaprb.com/blog/2006/05/18/why-null-never-compares-false-to-anything-in-sql/
- http://sqlmag.com/t-sql/coalesce-vs-isnull

** PRINT output not shown/displayed

If the variable is null, the entire *print* statement is rendering as null, and
*not printing at all*.

This will print:

#+begin_src sql
PRINT 'Output: ' + COALESCE(@myVar, '@myVar is null')
#+end_src

** Common operator for concatenation in Oracle and SQL Server

See http://stackoverflow.com/questions/1373238/string-concatenation-operator-in-oracle-postgres-and-sql-server

** Pattern Matching in Search Conditions (wildcards)

The ~LIKE~ keyword searches for character string, date, or time values that match
a specified pattern. For more information, see Data Types (Transact-SQL). The
~LIKE~ keyword uses a regular expression to contain the pattern that the values
are matched against. The pattern contains the character string to search for,
which can contain any combination of four wildcards.

| Wildcard | Meaning                                                                                                      |
|----------+--------------------------------------------------------------------------------------------------------------|
| %        | Any string of zero or more characters.                                                                       |
| _        | Any single character.                                                                                        |
| [ ]      | Any single character within the specified range (for example, [a-f]) or set (for example, [abcdef]).         |
| [^]      | Any single character not within the specified range (for example, [^a - f]) or set (for example, [^abcdef]). |

To escape underscore:
- Use brackets: ~[_]~
- Use ~LIKE '%\_xyz%' ESCAPE '\'~

** Select from the result of a union

https://www.pdrcorp.net/archibus/help/system/Content/wc_views/simple_views_techniques/Use_a_UNION_of_two_tables.htm

You should give an /alias/ to your table:

#+begin_src sql
SELECT A
FROM
(
    SELECT A, B FROM TableA
    UNION
    SELECT A, B FROM TableB
) AS tbl
WHERE B > 'some value'
#+end_src

** Use of DISTINCT and UNION

The use of ~DISTINCT~ is redundant when ~UNION~ is used since it already removes
duplicates.

However, ~UNION ALL~ does not eliminate duplicates.

** For each; avoid CURSOR, keep set logic

http://stackoverflow.com/questions/18513986/how-to-write-a-foreach-in-sql-server

** Different SQL JOINs

Different types of the SQL JOINs you can use:

- *[INNER] JOIN* (or older "comma join" with the JOIN condition in the WHERE clause) ::
     Returns all rows when there is at least one match in *both* tables

- *LEFT [OUTER] JOIN* ::
     Return all rows from the left table, and the matched rows from the right
     table

- *RIGHT [OUTER] JOIN* ::
     Return all rows from the right table, and the matched rows from the left
     table

- *FULL [OUTER] JOIN* ::
     Return all rows when there is a match in *one* of the tables

- *CROSS JOIN* ::
     Return every possible combination of rows from both tables (Cartesian
     product).

XXX

 Use an inner join when you want matching rows from both tables.
 Use a left or right outer join when you want to preserve all rows from one table and return only matching rows from the other.
 Use a left or right outer join with exclusions when you're looking for something in one table that doesn't exist in another table.
 Use a full outer join when you want all the rows from both sides, with nulls where they don't match.
 Use a cross join when you want to create a Cartesian product from two tables.



It is recommended that you not use RIGHT OUTER JOIN since a query can always be
rewritten to use LEFT OUTER JOIN which tends to be more portable and easier to
read.


http://stackoverflow.com/questions/448023/what-is-the-difference-between-left-right-outer-and-inner-joins

** Get index of last record in group of records

#+begin_src sql
  -- Get index of last record in group of prs records (same YYYY-MM).
  LastPrsCTE AS (
      SELECT
          prestations.prsPfiID_fk,
          prestations.prsAnnee,
          prestations.prsMois,
          prsIdx                        AS last_prsIdx
      FROM prestations
      INNER JOIN
      (   SELECT
              prsPfiID_fk,
              prsAnnee,
              prsMois,
              MAX(prsIdx)               AS max_prs_idx
          FROM prestations
          GROUP BY
              prsPfiID_fk,
              prsAnnee,
              prsMois
      ) AS last_prs
          ON prestations.prsPfiID_fk = last_prs.prsPfiID_fk
              AND prestations.prsIdx = last_prs.max_prs_idx
  ),
#+end_src

** Duplicate (some) rows

Déboubler les rows (autrement que par un ~JOIN~) :

#+begin_src sql
SELECT date_start AS meeting_date, 'AM' AS meeting_time_of_day
FROM reserve_rm
WHERE CONVERT(varchar(5), time_start, 108) < '13:00'

UNION ALL

SELECT date_start AS meeting_date, 'PM' AS meeting_time_of_day
FROM reserve_rm
WHERE CONVERT(varchar(5), time_end, 108) > '13:00'
#+end_src

** SQL WHERE.. IN clause multiple columns

http://stackoverflow.com/questions/1136380/sql-where-in-clause-multiple-columns

#+begin_src sql
SELECT *
FROM table
INNER JOIN otherTable ON (table.x = otherTable.a AND table.y = otherTable.b)
#+end_src

or use the ~WHERE EXISTS~ syntax instead.

** COUNT DISTINCT sur 2 champs

Concaténer les 2 champs pour ensuite faire le ~COUNT~.

#+begin_src sql
SELECT COUNT(DISTINCT commande + CAST(produit AS nvarchar)) AS test
FROM produits
WHERE ....
#+end_src

#+begin_warning
*Séparateur recommandé dans la concaténation.* Sinon 10-1500 sera identique
à 101-500 (idem avec les lettres).
#+end_warning

** How can I do an UPDATE statement with JOIN in SQL?

http://stackoverflow.com/questions/1293330/how-can-i-do-an-update-statement-with-join-in-sql

** Common Table Expressions

This feature is great for breaking the problem down into easily understood
chunks. It helps make queries easier to understand. For example:

#+begin_src sql
WITH
    payment_notes_xml AS (
        SELECT
            id                                    AS payment_id,
            unnest(xpath('//NOTE', notes :: XML)) AS note_xml
        FROM payments
    )
INSERT INTO payment_notes (payment_id, note, type)
    SELECT
        payment_id,
        xpath('//TEXT/text()') AS note,
        xpath('//TYPE/text()') AS type
    FROM payment_notes_xml
#+end_src

Common table expressions (CTE) allow you to name a query for later use in your
SQL. CTE's can be read from (and joined to) as if they were a table in your
database.

A CTE is basically a disposable view. It only persists for a single statement,
and then automatically disappears.

The options to *use one CTE many times* (in many statements) include:

- Redefine the CTE a second time. This is as simple as copy-paste from ~WITH...~
  through the end of the definition.

- Put the results into a ~#temp~ table or a ~@table~ variable.

- Materialize the results into a real table and reference that.

** Return the current version

#+begin_src sql
-- For SQL Server.
SELECT @@VERSION AS "SQL Server Version";
#+end_src

#+begin_src sql
-- For Oracle.
SELECT banner AS "Oracle version"
FROM v$version
WHERE banner LIKE 'Oracle%';
#+end_src

** Set Oracle date display format (ISO 8601)

#+begin_src sql
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';
#+end_src

** NULL-Aware comparison

"Boolean" logic in SQL is a bit complicated, because it is a *three-valued logic*
with ~true~, ~false~, and ~NULL~.  ~NULL~ fails basically all comparisons, so it fails
~a = b~ and ~a <> b~.

*NOTE --* Not always true; see [[https://docs.microsoft.com/fr-fr/sql/t-sql/statements/set-ansi-nulls-transact-sql?view=sql-server-ver15][SETANSI_NULLS (Transact-SQL)]] for more information.

#+begin_warning
In SQL, ~NULL~ is *not equal* (~=~) to anything -- not even to another ~NULL~.
According to the three-valued logic of SQL, the result of ~NULL = NULL~ is not the
boolean value /true/ but /unknown/ -- it is a *non-value*.

Unfortunately, not only is ~NULL~ not equal to anything, it's also *not unequal* to
anything.  This is where the language is confusing.

Here are two common queries that just don't work:

: SELECT * FROM table WHERE column = NULL;
: SELECT * FROM table WHERE column <> NULL;

They both return *no* rows!

The right way to think about ~NULL~ -- The correct way to understand NULL is that
it is not a value.  Not "this is a ~NULL~ value" but "this ~NULL~ is not a value."
Everything either is a value, or it isn’t.  When something is a value, it is
"1," or "hello," or "green," or "$5.00" etc -- but when something isn’t a value,
*it just isn’t anything at all*.  SQL represents "this has no value" by the
special non-value ~NULL~.  When someone says "the ~NULL~ value," one should mentally
disagree, because there’s *no such thing*.  ~NULL~ is the complete, total absence of
any value whatsoever.
#+end_warning

The correct way to write the queries -- SQL has the special ~IS [NOT] NULL~
comparison predicate to test if a particular value is ~NULL~.

: SELECT * FROM table WHERE column IS NULL;
: SELECT * FROM table WHERE column IS NOT NULL;

And the "functional opposite" of:

#+begin_src sql
   (a = b)
OR (a IS NULL AND b IS NULL)
#+end_src

in a ~WHERE~ clause would then be:

#+begin_src sql
   (a <> b)
OR (a IS NOT NULL AND b IS NULL)
OR (a IS NULL AND b IS NOT NULL)
#+end_src

** Export table to CSV (Oracle)

By design, SQL Developer only shows 5,000 records from any query, and 10,010
rows of output in total for a single script execution.

Increase those preferences in ~Database~ > ~Worksheet~ > ~Max Rows to print in
a script~ and ~Max lines in Script output~.

#+begin_src sql
-- SET ECHO OFF
-- SET HEADING ON
-- SET FEEDBACK OFF
SET COLSEP ';'

-- N should be the length you want for numbers (avoid scientific notation on IDs).
SET NUMWIDTH 10

-- N should be the sum of the column widths.
SET LINESIZE 9999

-- One header row every 50,000 rows.
SET PAGESIZE 50000

SPOOL table_rmpct.csv

-- Query.
SELECT * FROM rmpct ORDER BY pct_id;

SPOOL OFF
#+end_src

Could be used in a script with ~sqlplus -s~ and the SQL commands in a /heredoc/
section, followed by:

#+begin_src shell
# Remove leading and trailing spaces in cells.
grep -v -- ----- table_rmpct.csv | sed 's/; */;/g' | sed 's/ *;/;/g' | sponge table_rmpct.csv
#+end_src

** TODO Tips and Tricks to Make SQL Server Management Studio Awesome

- http://blogs.lessthandot.com/index.php/datamgmt/dbprogramming/tips-and-tricks-to-make/
  Shortcuts, defaults, etc.

** Oracle ROWNUM vs. SQL Server TOP -- Query across both databases

#+begin_src sql
-- TOP 10 for both SQL Server and Oracle.
SELECT *
FROM
(
    SELECT
        pct_id,
        RANK() OVER(ORDER BY pct_id DESC) rmpct_rank
    FROM rmpct
) t
WHERE rmpct_rank <= 10
ORDER BY pct_id;
#+end_src

** List table spaces in Oracle

#+begin_src shell
-- List of tablespaces (for Oracle).
SELECT
    TABLESPACE_NAME,
    BLOCK_SIZE,
    STATUS,
    CONTENTS,
    EXTENT_MANAGEMENT,
    ALLOCATION_TYPE,
    SEGMENT_SPACE_MANAGEMENT
FROM DBA_TABLESPACES
ORDER BY TABLESPACE_NAME;
#+end_src

#+begin_src shell
-- List of tablespaces with the OS files (for Oracle).
SELECT *
FROM
   (SELECT
        TABLESPACE_NAME,
        FILE_NAME,
        FILE_ID,
        BYTES,
        STATUS,
        MAXBYTES
    FROM DBA_DATA_FILES
    UNION
    SELECT
        TABLESPACE_NAME,
        FILE_NAME,
        FILE_ID,
        BYTES,
        STATUS,
        MAXBYTES
    FROM DBA_TEMP_FILES)
WHERE TABLESPACE_NAME LIKE UPPER('%%')
ORDER BY TABLESPACE_NAME, FILE_NAME;
 #+end_src

#+begin_src shell
SELECT tablespace_name, file_name
FROM dba_temp_files;

CREATE TEMPORARY TABLESPACE temp2
    TEMPFILE 'D:\temp2.dbf'
    SIZE 100m AUTOEXTEND ON NEXT 100m MAXSIZE 200m;

ALTER DATABASE DEFAULT TEMPORARY TABLESPACE temp2;

SELECT property_name, property_value
FROM database_properties
WHERE property_name='DEFAULT_TEMP_TABLESPACE';

DROP TABLESPACE temp3 INCLUDING CONTENTS AND DATAFILES;
#+end_src

** Debug - See line giving error in Oracle

#+begin_src shell
EXEC dbms_output.ENABLE(99999999);
SET serveroutput on format wrapped;
#+end_src

** SQL Server - Trace SQL

#+begin_src sql
DROP EVENT SESSION [afm-session-sql] ON SERVER;

CREATE EVENT SESSION [afm-session-sql] ON SERVER
ADD EVENT sqlserver.sp_statement_completed(SET collect_statement=(1)
    ACTION(sqlserver.sql_text,sqlserver.username)
    WHERE ([sqlserver].[like_i_sql_unicode_string]([sqlserver].[username],N'%afm%'))
       AND ([sqlserver].[like_i_sql_unicode_string]([sqlserver].[sql_text],N'SELECT%') OR
            [sqlserver].[like_i_sql_unicode_string]([sqlserver].[sql_text],N'DELETE%') OR
              [sqlserver].[like_i_sql_unicode_string]([sqlserver].[sql_text],N'UPDATE%')
             )
             ),
ADD EVENT sqlserver.sql_statement_completed(SET collect_statement=(1)
    ACTION(sqlserver.sql_text,sqlserver.username)
    WHERE ([sqlserver].[like_i_sql_unicode_string]([sqlserver].[username],N'%afm%'))
       AND ([sqlserver].[like_i_sql_unicode_string]([sqlserver].[sql_text],N'SELECT%') OR
            [sqlserver].[like_i_sql_unicode_string]([sqlserver].[sql_text],N'DELETE%') OR
              [sqlserver].[like_i_sql_unicode_string]([sqlserver].[sql_text],N'UPDATE%')
             )
             )
ADD TARGET package0.event_file(SET filename=N'c:\temp\afm-session-sql')
WITH (MAX_MEMORY=2048 KB,EVENT_RETENTION_MODE=ALLOW_SINGLE_EVENT_LOSS,MAX_DISPATCH_LATENCY=3 SECONDS,MAX_EVENT_SIZE=0 KB,MEMORY_PARTITION_MODE=NONE,TRACK_CAUSALITY=OFF,STARTUP_STATE=OFF)
go
#+END_SRC

** SQL Dates

https://www.sqldates.com/

** Code formatting

- http://programmers.stackexchange.com/questions/160522/should-i-put-newlines-before-or-after-binary-operators

  The "joining" condition is very important and it tends to get overlooked at
  the end of the previous line.

- [[http://sqlformat.org/][Online SQL formatting service]]
  [[http://www.sql-format.com/][SQL Formatter for SQL Server]]

  The [[http://www.ssmsboost.com/][SSMSBoost]] plugin allows, among others, to reformat SQL code.

  In Oracle SQL Developer, use ~C-F7~ to format SQL.
  http://www.thatjeffsmith.com/archive/2012/11/keyboard-shortcuts-in-oracle-sql-developer/

  It also exists in SQL Management Studio (other key binding)!

  *Read http://stackoverflow.com/questions/101079/sql-server-management-studio-tips-for-improving-the-tsql-coding-process!*

- Arjan Kemeling is a big fan of *DBVisualizer Pro*. Works great on all databases,
  allows SQL code formatting, import data from txt, Excel,... straight into the
  database (new or existing table), you can also create SQL queries by selecting
  tables, fields in de query builder or start from an existing SQL query, it
  draws interactive database schemas (based on FKs), it has very handy "copy
  selection as" features, launch SQL query and modify resulting data which you
  can either save immediately or export to SQL queries or files, .... the list
  goes on and on. The only thing it does not do is compare databases, tables or
  data.

** Table name as variable

Table names and column names need to be static, if the query is static.  For
dynamic table or column names, you should generate the full SQL dynamically, and
use ~EXEC sp_executesql~ to execute it.

More details here: [[http://www.sommarskog.se/dynamic_sql.html][The curse and blessings of dynamic SQL]].

** SQL Loop

*** While loop with temporary table

#+begin_src sql
-- Create a new table using the schema of another.
SELECT TABLE_NAME
INTO #TablesToControl
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_TYPE = 'BASE TABLE' -- OR TABLE_TYPE = 'VIEW'

DECLARE @TableName varchar(128)

WHILE EXISTS (SELECT 1 FROM #TablesToControl)
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from interfering with
    -- SELECT statements.
    SET NOCOUNT ON;

    SELECT @TableName = (SELECT TOP 1 TABLE_NAME
                         FROM #TablesToControl
                         ORDER BY TABLE_NAME)

    -- Do something with your @TableName.
    DECLARE @Sql nvarchar(4000);
    SELECT @Sql = N' SELECT ''' + QUOTENAME(@TableName) + ''', COUNT(*) ' +
                   ' FROM ' + QUOTENAME(@TableName);
                                        -- QUOTENAME is important for security.
    SELECT @Sql = N' IF EXISTS (SELECT 1 FROM ' + QUOTENAME(@TableName) + ') ' +
                   '     PRINT ''' + @TableName + '''';
    EXEC sp_executesql @Sql

    -- Remove the table name from the temporary table.
    DELETE FROM #TablesToControl
    WHERE TABLE_NAME = @TableName
END

DROP TABLE #TablesToControl;
#+end_src

Other info at
http://stackoverflow.com/questions/18513986/how-to-write-a-foreach-in-sql-server

*** Cursor-like FETCH-NEXT logic

https://stackoverflow.com/questions/11852782/t-sql-loop-over-query-results

*** Cursor

Cursors are slower than while loops?

** SQL error on update: The UPDATE statement conflicted with the FOREIGN KEY constraint

https://stackoverflow.com/questions/23856420/sql-error-on-update-the-update-statement-conflicted-with-the-foreign-key-const

** Debugging triggers

The login for the developer must be a *member of the sysadmin server role*.

SQL Debugging significantly exposes the SQL Server Process - this is why it
requires sysadmin permission. If you don't want your developers to be sysadmin,
then you probably don't want them to be debugging in this way.

This feature was really designed for developers working on their own
workstations, not for use on production servers or other scenarios where there
are reasons you wouldn't want your developers to be sysadmin on the sql server
being debugged.

** Conversion failed when converting date and/or time from character string while inserting datetime

Whenever possible one should avoid culture specific date/time literals. There
are some secure formats:

All examples for 2016-09-15 17:30:00

ODBC (my favorite, as it is handled as the real type immediately)
{ts'2016-09-15 17:30:00'} --Time Stamp
{d'2016-09-15'} --Date only
{t'17:30:00'} --Time only

ISO8601 (the best for everywhere)
2016-09-15T17:30:00 --be aware of the T in the middle!

Unseparated (tiny risk to get misinterpreted as number)
20160915 --only for pure date

Invalid dates tend to show up with strange errors
There is no 31st of June or 30th of February...

One more reason: Order of execution!

SQL-Server is well know to do things in an order of execution one might not have
expected. Here is a great article: Rusano.com:
"t-sql-functions-do-no-imply-a-certain-order-of-execution" and here is the
related question.

** 6 Useful SQL Server Data Dictionary Queries Every DBA Should Have

https://dataedo.com/blog/useful-sql-server-data-dictionary-queries-every-dba-should-have

1. List of tables with number of rows and comments
2. List of views with definition and comments
3. Table columns details
4. Foreign keys
5. Views columns
6. Tables by number of columns

** Over 40 queries to find SQL Server tables with or without a certain property

https://www.mssqltips.com/sqlservertip/3402/over-40-queries-to-find-sql-server-tables-with-or-without-a-certain-property/

** List all constraints

#+begin_src sql
EXEC sp_help 'rm';
#+end_src

#+begin_src sql
-- Return 1 row for each CHECK, UNIQUE, PRIMARY KEY, FOREIGN KEY, and/or DEFAULT.
SELECT
    -- SCHEMA_NAME(schema_id)           AS SCHEMA_NAME,
    OBJECT_NAME(parent_object_id)       AS TABLE_NAME,
    type_desc                           AS CONSTRAINT_TYPE,
    OBJECT_NAME(OBJECT_ID)              AS CONSTRAINT_NAME
FROM sys.objects
WHERE
    OBJECT_NAME(parent_object_id) LIKE '%%'
    AND type_desc LIKE '%CONSTRAINT'    -- Ignore SQL triggers.
    AND OBJECT_NAME(OBJECT_ID) LIKE '%%'
ORDER BY
    table_name,
    constraint_type DESC,
    constraint_name;
#+end_src

If you need even more constraint information, look inside the stored procedure
~sp_helpconstraint~ to see how to get certain information.  To view the source
code using SQL Server Management Studio, get into the "Object Explorer".

** List all PRIMARY KEY constraints

#+begin_tip
~EXEC sp_pkeys~ will return a row for each column that participates in the primary
key for the table.  The columns you are likely most interested in are
~COLUMN_NAME~ and ~PK_NAME~.
#+end_tip

#+begin_src sql
-- For SQL Server.
-- Correct results for em (email not in em_PK) or eq (see EPO).
SELECT
    KU.TABLE_CATALOG                    AS TABLE_QUALIFIER,
    KU.TABLE_SCHEMA                     AS TABLE_OWNER,
    KU.TABLE_NAME,
    KU.COLUMN_NAME,
    KU.ORDINAL_POSITION                 AS KEY_SEQ,
    KU.CONSTRAINT_NAME                  AS PK_NAME
FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS TC
INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE KU
    ON (CONSTRAINT_TYPE = 'PRIMARY KEY'
        AND TC.CONSTRAINT_NAME = KU.CONSTRAINT_NAME)
WHERE
    KU.TABLE_SCHEMA = 'afm'
    AND KU.TABLE_NAME LIKE '%%'
    AND KU.CONSTRAINT_NAME LIKE '%%'
ORDER BY
    KU.TABLE_NAME,
    KU.ORDINAL_POSITION;
#+end_src

#+begin_note
Avoid using ~INFORMATION_SCHEMA~ views.  Worth reading Aaron's post on
[[http://sqlblog.com/blogs/aaron_bertrand/archive/2011/11/03/the-case-against-information-schema-views.aspx][The case against INFORMATION_SCHEMA views]].

Though, at http://stackoverflow.com/questions/219434/query-to-list-all-stored-procedures,
they say that the *best way* is to *use the INFORMATION_SCHEMA tables*!???

Using ~INFORMATION_SCHEMA~ (in contrast to the ~sys.~ views) is always a good idea
as it is the official standard and is implemented in a couple other database
systems.
#+end_note

#+begin_src sql
-- For Oracle.
SELECT
    all_cons_columns.owner              AS schema_name,
    all_cons_columns.table_name,
    all_cons_columns.column_name,
    all_cons_columns.position,
    all_constraints.constraint_name
FROM all_constraints, all_cons_columns
WHERE
    all_constraints.constraint_type = 'P' -- Primary key.
    AND all_constraints.owner = all_cons_columns.owner
    AND all_constraints.constraint_name = all_cons_columns.constraint_name
    AND all_constraints.status = 'ENABLED'
    AND all_cons_columns.owner LIKE '%%'
    AND all_cons_columns.table_name LIKE '%%'
    AND all_constraints.constraint_name LIKE '%%'
ORDER BY
    all_cons_columns.owner,
    all_cons_columns.table_name,
    all_cons_columns.position;
#+end_src

** List all FOREIGN KEY constraints

#+begin_tip
~EXEC sp_helpconstraint 'rm'~ will list:
- all *constraints* for the table,
- including *foreign keys that reference* the table (see also ~EXEC sp_fkeys~).

In the first recordset, there will only be a column called ~Object Name~ (kind of
useless, since that's what you passed in).

In the second resultset, there will be the following columns: ~constraint_type~,
~constraint_name~, and ~constraint_keys~.
#+end_tip

#+begin_tip
Reversely, ~EXEC sp_fkeys~ retrieves a list of *foreign keys REFERENCING* a table.
#+end_tip

#+begin_src sql
-- For SQL Server.
-- This query finds the constraint rm_rm_std in EPO.  Other flavors don't.
SELECT
    SCHEMA_NAME(fkt.schema_id)          AS FK_TABLE_SCHEMA_NAME,
    fkt.name                            AS FK_TABLE_NAME,  -- Referencing table.
    fkc.name                            AS FK_COLUMN_NAME, -- Referencing column.
    fkc.max_length                      AS FK_SIZE,
    fk.name                             AS FK_NAME,        -- Foreign Key CONSTRAINT_NAME.
    sfkc.constraint_column_id           AS FK_PART,
    SCHEMA_NAME(pkt.schema_id)          AS PK_TABLE_SCHEMA_NAME,
    pkt.name                            AS PK_TABLE_NAME,  -- Referenced table.
    pkc.name                            AS PK_COLUMN_NAME, -- Referenced column.
    pkc.max_length                      AS PK_SIZE,
    CASE OBJECTPROPERTY(fk.OBJECT_ID, 'CnstIsDeleteCascade')
        WHEN 0                          THEN '0 = No Action'
        WHEN 1                          THEN '1 = Cascade'   -- True.
        WHEN 2                          THEN '2 = Set Null'
        WHEN 3                          THEN '3 = Set Default'
                                        ELSE ''
    END                                 AS delete_action,
    CASE OBJECTPROPERTY(fk.OBJECT_ID, 'CnstIsUpdateCascade')
        WHEN 0                          THEN '0 = No Action'
        WHEN 1                          THEN '1 = Cascade'   -- True.
        WHEN 2                          THEN '2 = Set Null'
        WHEN 3                          THEN '3 = Set Default'
                                        ELSE ''
    END                                 AS update_action,
    CASE is_disabled
        WHEN 1                          THEN '1 = Disabled'
                                        ELSE 'Enabled'
    END                                 AS status_enabled  -- WITH NOCHECK.
FROM sys.foreign_keys                   fk
JOIN sys.foreign_key_columns            sfkc
    ON sfkc.constraint_object_id = fk.object_id
JOIN sys.tables                         fkt
    ON fkt.object_id = fk.parent_object_id
JOIN sys.columns                        fkc
    ON sfkc.parent_object_id = fkc.object_id AND sfkc.parent_column_id = fkc.column_id
JOIN sys.tables                         pkt
    ON pkt.object_id = fk.referenced_object_id
JOIN sys.columns                        pkc
    ON sfkc.referenced_object_id = pkc.object_id AND sfkc.referenced_column_id = pkc.column_id
WHERE
    fkt.name     LIKE '%%'              AND fkc.name LIKE '%%'
    AND fk.name  LIKE '%%'
    AND pkt.name LIKE '%%'              AND pkc.name LIKE '%%'
ORDER BY
    SCHEMA_NAME(fkt.schema_id),
    fkt.name,
    pkt.name,
    fk.name,
    sfkc.constraint_column_id;
#+end_src

#+begin_src sql
-- For Oracle.
SELECT
    owner,
    table_name,
    constraint_name,
    r_constraint_name
FROM all_constraints
WHERE
    table_name LIKE '%%'
    AND UPPER(constraint_name) LIKE UPPER('%%')
    AND UPPER(constraint_type) = 'R'    -- Foreign key.
    AND UPPER(status) = 'ENABLED';
#+end_src

#+begin_src sql
-- For Oracle.
SELECT DISTINCT
    table_name,
    column_name,
    constraint_name,
    position,
    r_table_name
FROM
(
    SELECT
        uc.table_name,
        uc.constraint_name,
        cols.column_name,
        (
            SELECT table_name
            FROM user_constraints
            WHERE constraint_name = uc.r_constraint_name
        )                               r_table_name,
        (
            SELECT column_name
            FROM user_cons_columns
            WHERE constraint_name = uc.r_constraint_name
                  AND position = cols.position
        )                               r_column_name,
        cols.position,
        uc.constraint_type
    FROM user_constraints               uc
    INNER JOIN user_cons_columns        cols
        ON uc.constraint_name = cols.constraint_name
    WHERE constraint_type <> 'C'
)
WHERE TABLE_name LIKE '%%'
  AND r_table_name LIKE '%%'
CONNECT BY
NOCYCLE
    PRIOR table_name = r_table_name
    AND PRIOR column_name = r_column_name
ORDER BY
    table_name,
    r_table_name,
    position;
#+end_src

#+begin_src sql
-- For Oracle.
SELECT
    owner,
    table_name,
    constraint_name,
    r_owner,
    r_constraint_name,
    status
FROM all_constraints
WHERE constraint_type = 'R'             -- Referential integrity
    AND r_constraint_name IN
    (
        SELECT constraint_name
        FROM all_constraints
        WHERE constraint_type IN ('P', 'U') -- Primary key or Unique
            AND table_name LIKE UPPER('%')
    )
ORDER BY
    table_name,
    constraint_name;
#+end_src

*** The DELETE statement conflicted with the REFERENCE constraint

#+begin_src sql :tangle no
DELETE FROM reserve_request WHERE datediff(DD, meeting_date, '2018-09-06') >= 380
-- Query executed successfully.

DELETE FROM reserve WHERE datediff(DD, date_start, '2018-09-06') >= 380
-- The DELETE statement conflicted with the REFERENCE constraint "res_req_res_id". The conflict occurred in database "EPO_20180129_CAFM_PRD", table "afm.reserve_request", column 'res_id'.
#+end_src

Find the record from ~FK_TABLE_NAME~ which has a reference in ~PK_TABLE_NAME~:

#+begin_src sql
SELECT
    'reserve_request'                   AS FK_TABLE_NAME,
    FK_TABLE_NAME.res_id                AS FK_COLUMN_NAME,
    FK_TABLE_NAME.meeting_date,
    'reserve'                           AS PK_TABLE_NAME,
    PK_TABLE_NAME.res_id                AS PK_COLUMN_NAME,
    PK_TABLE_NAME.date_start
FROM reserve_request                    FK_TABLE_NAME
LEFT JOIN reserve                       PK_TABLE_NAME
    ON FK_TABLE_NAME.res_id = PK_TABLE_NAME.res_id
WHERE
    -- DATEDIFF(DD, FK_TABLE_NAME.meeting_date, '2018-09-06') >= 380
    -- OR
    DATEDIFF(DD, PK_TABLE_NAME.date_start, '2018-09-06') >= 380;
#+end_src

** Enable / disable all constraints in the database

#+begin_src sql
-- Disable all constraints for database.
EXEC sp_MSforeachtable "ALTER TABLE ? NOCHECK CONSTRAINT all"
#+end_src

To switch them back on, run: (the print is optional of course and it is just
listing the tables)

#+begin_src sql
-- Enable all constraints for database.
EXEC sp_MSforeachtable @command1="print '?'", @command2="ALTER TABLE ? WITH CHECK CHECK CONSTRAINT all"
#+end_src

I find it useful when populating data from one database to another.  It is much
better approach than dropping constraints.  It comes handy when dropping all the
data in the database and repopulating it (say, in test environment).

** Enable / disable all constraints on a table

#+begin_src sql
-- Disable all table constraints.
ALTER TABLE ${1:[schema].[table_name]} NOCHECK CONSTRAINT ALL;

-- Enable all table constraints.
ALTER TABLE ${1:[schema].[table_name]} WITH CHECK CHECK CONSTRAINT ALL;

-- Disable single constraint.
ALTER TABLE ${1:[schema].[table_name]} NOCHECK CONSTRAINT $0;

-- Enable single constraint.
ALTER TABLE ${1:[schema].[table_name]} WITH CHECK CHECK CONSTRAINT $0;
#+end_src

#+begin_src sql
-- For Oracle.

-- Enable primary key (constraint_type ='P') constraint.
ALTER TABLE ${1:[schema].[table_name]} ENABLE CONSTRAINT $0;

-- Enable all primary keys on all tables.
BEGIN
   FOR rec IN (SELECT owner, table_name, constraint_name
               FROM all_constraints
               WHERE UPPER(constraint_type) = 'P'
                   AND UPPER(owner) IN ('AFM', 'AFM_SECURE')
                   AND status = 'DISABLED')
   LOOP
      EXECUTE IMMEDIATE 'ALTER TABLE "' || rec.owner || '"."' || rec.table_name || '" ENABLE CONSTRAINT "' || rec.constraint_name || '"';
   END LOOP;
END;
#+end_src

#+begin_src sql
-- For Oracle.

-- Enable foreign key (constraint_type ='R') constraint without validation.
ALTER TABLE ${1:[schema].[table_name]} ENABLE NOVALIDATE CONSTRAINT $0;

-- Enable all foreign keys on all tables.
BEGIN
   FOR rec IN (SELECT owner, table_name, constraint_name
               FROM all_constraints
               WHERE UPPER(constraint_type) = 'R'
                   AND UPPER(owner) IN ('AFM', 'AFM_SECURE')
                   AND status = 'DISABLED')
   LOOP
      EXECUTE IMMEDIATE 'ALTER TABLE "' || rec.owner || '"."' || rec.table_name || '" ENABLE NOVALIDATE CONSTRAINT "' || rec.constraint_name || '"';
   END LOOP;
END;
#+end_src

** List all non-NULLABLE columns

#+begin_tip
SQL will use the *default value* if you do *not declare* the *non-nullable column* in
the ~INSERT~ statement.
#+end_tip

#+begin_src sql
SELECT
    OBJECT_NAME(object_id)              AS TABLE_NAME,
    name                                AS COLUMN_NAME,
    CASE is_nullable
        WHEN 0 THEN '0 = No'
        WHEN 1 THEN '1 = Yes'
        ELSE NULL
    END                                 AS IS_NULLABLE
    -- XXX Add the default value
FROM sys.columns
WHERE
    object_id = OBJECT_ID('rmpct')
    AND is_nullable = 0                 -- NO.
ORDER BY
    OBJECT_NAME(object_id),
    name;
#+end_src

** List all DEFAULT constraints (with default value)

#+begin_src sql
SELECT
    t.name                              AS TABLE_NAME,
    c.name                              AS COLUMN_NAME,
    dc.name                             AS CONSTRAINT_NAME,
    dc.definition
FROM sys.tables                         t
INNER JOIN sys.default_constraints      dc
    ON t.object_id = dc.parent_object_id
INNER JOIN sys.columns                  c
    ON dc.parent_object_id = c.object_id AND dc.parent_column_id = c.column_id
WHERE
    t.name LIKE '%%'
    AND c.name LIKE '%%'
ORDER BY
    t.name,
    c.name;
#+end_src

** List all IDENTITY columns

#+begin_src sql
SELECT
    o.name                              AS TABLE_NAME,
    c.name                              AS COLUMN_NAME,
    c.is_identity                       AS IS_IDENTITY
FROM sys.objects                        o
INNER JOIN sys.columns                  c
    ON o.object_id = c.object_id
WHERE
    c.is_identity = 1
    AND o.name LIKE '%%'
    AND c.name LIKE 'cascading_id'
ORDER BY o.name;
#+end_src

~SET IDENTITY_INSERT <table>~

- ON ::
     *Permit the insertion of an EXPLICIT value for the identity column* of
     a table.

- OFF ::
     Revert the granted permission.

If there is an error when inserting (Cannot insert explicit value for identity
column in table when ~IDENTITY_INSERT~ is set to ~OFF~), the solution is either:

- insert without specifying the value for the identity column, and let SQL
  Server do (= adviced), or

- ~SET IDENTITY_INSERT~ to ~ON~ for the table (= not adviced).

#+begin_warning
At any time, *only one table in a session* can have the ~IDENTITY_INSERT~ property
set to ~ON~.
#+end_warning

*** How to remove Identity from a column in a table?

https://stackoverflow.com/questions/8230257/remove-identity-from-a-column-in-a-table

If you want to do this *without adding and populating a new column, without
reordering the columns*, and *with almost no downtime* because no data is changing
on the table, let's do some magic with partitioning functionality (but since no
partitions are used you don't need Enterprise edition):

#+begin_src sql
-- Create new table with no IDENTITY.
CREATE TABLE [afm].[hrmpct_2](
    [ac_id] [varchar](32) NULL,
    [activity_log_id] [int] NULL,
    [area_chargable] [numeric](7, 2) NOT NULL,
    [area_comn] [numeric](7, 2) NOT NULL,
    [area_comn_nocup] [numeric](7, 2) NOT NULL,
    [area_comn_ocup] [numeric](7, 2) NOT NULL,
    [area_comn_rm] [numeric](7, 2) NOT NULL,
    [area_comn_serv] [numeric](7, 2) NOT NULL,
    [area_rm] [numeric](8, 2) NOT NULL,
    [bl_id] [varchar](8) NULL,
    [cost] [numeric](9, 2) NOT NULL,
    [date_created] [datetime] NULL,
    [date_deleted] [datetime] NULL,
    [date_end] [datetime] NULL,
    [date_start] [datetime] NULL,
    [day_part] [smallint] NOT NULL,
    [del_user_name] [varchar](64) NULL,
    [dp_id] [varchar](60) NULL,
    [dv_id] [varchar](60) NULL,
    [em_id] [varchar](60) NULL,
    [fl_id] [varchar](4) NULL,
    [from_bl_id] [varchar](8) NULL,
    [from_fl_id] [varchar](4) NULL,
    [from_rm_id] [varchar](8) NULL,
    [mo_id] [int] NULL,
    [org_id] [varchar](60) NULL,
    [parent_pct_id] [int] NULL,
    [pct_space] [numeric](6, 2) NULL,
    [pct_time] [numeric](6, 2) NULL,
    [primary_em] [smallint] NULL,
    [primary_rm] [smallint] NULL,
    [prorate] [varchar](8) NOT NULL,
    [resources] [varchar](5000) NULL,
    [rm_cat] [varchar](12) NULL,
    [rm_id] [varchar](8) NULL,
    [rm_type] [varchar](50) NULL,
    [status] [smallint] NOT NULL,
    [user_name] [varchar](64) NULL,
    [visitor_id] [int] NULL,
    [pct_id] [int] NOT NULL,
    [confirmed] [smallint] NOT NULL DEFAULT ((0)),
    CONSTRAINT [hrmpct_PK_2] PRIMARY KEY CLUSTERED
    (
        [pct_id] ASC
    ) WITH (PAD_INDEX = ON, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 85)
)
go

-- Data before switch.
SELECT 'hrmpct', pct_id, *
FROM hrmpct
UNION ALL
SELECT 'hrmpct_2', pct_id, *
FROM hrmpct_2;

-- Switch.
ALTER TABLE hrmpct SWITCH TO hrmpct_2;

-- Data after switch.
SELECT 'hrmpct', pct_id, *
FROM hrmpct
UNION ALL
SELECT 'hrmpct_2', pct_id, *
FROM hrmpct_2;

-- Clean up.
DROP TABLE hrmpct;

EXEC sys.sp_rename 'hrmpct_2.hrmpct_PK_2', 'hrmpct_PK';
EXEC sys.sp_rename 'hrmpct_2', 'hrmpct', 'OBJECT';

ALTER TABLE hrmpct ADD CONSTRAINT [DF__hrmpct__area_cha__4DD54A14] DEFAULT ((0.0))     FOR [area_chargable];
ALTER TABLE hrmpct ADD CONSTRAINT [DF__hrmpct__area_com__4EC96E4D] DEFAULT ((0.0))     FOR [area_comn];
ALTER TABLE hrmpct ADD CONSTRAINT [DF__hrmpct__area_com__4FBD9286] DEFAULT ((0.0))     FOR [area_comn_nocup];
ALTER TABLE hrmpct ADD CONSTRAINT [DF__hrmpct__area_com__50B1B6BF] DEFAULT ((0.0))     FOR [area_comn_ocup];
ALTER TABLE hrmpct ADD CONSTRAINT [DF__hrmpct__area_com__51A5DAF8] DEFAULT ((0.0))     FOR [area_comn_rm];
ALTER TABLE hrmpct ADD CONSTRAINT [DF__hrmpct__area_com__5299FF31] DEFAULT ((0.0))     FOR [area_comn_serv];
ALTER TABLE hrmpct ADD CONSTRAINT [DF__hrmpct__area_rm__538E236A]  DEFAULT ((0.0))     FOR [area_rm];
ALTER TABLE hrmpct ADD CONSTRAINT [DF__hrmpct__cost__55766BDC]     DEFAULT ((0.0))     FOR [cost];
ALTER TABLE hrmpct ADD CONSTRAINT [DF__hrmpct__date_cre__566A9015] DEFAULT (getdate()) FOR [date_created];
ALTER TABLE hrmpct ADD CONSTRAINT [DF__hrmpct__date_del__575EB44E] DEFAULT (getdate()) FOR [date_deleted];
ALTER TABLE hrmpct ADD CONSTRAINT [DF__hrmpct__day_part__5A3B20F9] DEFAULT ((0))       FOR [day_part];
ALTER TABLE hrmpct ADD CONSTRAINT [DF__hrmpct__pct_spac__65ACD3A5] DEFAULT ((100.00))  FOR [pct_space];
ALTER TABLE hrmpct ADD CONSTRAINT [DF__hrmpct__pct_time__66A0F7DE] DEFAULT ((100.00))  FOR [pct_time];
ALTER TABLE hrmpct ADD CONSTRAINT [DF__hrmpct__prorate__697D6489]  DEFAULT ('NONE')    FOR [prorate];
ALTER TABLE hrmpct ADD CONSTRAINT [DF__hrmpct__status__6E4219A6]   DEFAULT ((1))       FOR [status];

-- Test.
SELECT TOP 10 pct_id, *
FROM hrmpct;

UPDATE hrmpct
SET pct_id = pct_id + 1;

SELECT TOP 10 pct_id, *
FROM hrmpct;
#+end_src

** List triggers

https://stackoverflow.com/questions/4305691/need-to-list-all-triggers-in-sql-server-database-with-table-name-and-tables-sch
to *list database triggers* as well!

#+begin_src sql
SELECT
    OBJECT_NAME(so.parent_obj)          AS TABLE_NAME,
    so.name                             AS TRIGGER_NAME,
    OBJECTPROPERTY(so.id, 'ExecIsInsertTrigger')    AS "INSERT",
    OBJECTPROPERTY(so.id, 'ExecIsUpdateTrigger')    AS "UPDATE",
    OBJECTPROPERTY(so.id, 'ExecIsDeleteTrigger')    AS "DELETE",
    OBJECTPROPERTY(so.id, 'ExecIsAfterTrigger')     AS AFTER,
    OBJECTPROPERTY(so.id, 'ExecIsInsteadOfTrigger') AS INSTEAD_OF,
    OBJECTPROPERTY(so.id, 'ExecIsTriggerDisabled')  AS DISABLED
FROM sysobjects                         so
INNER JOIN sysobjects                   so2
    ON so.parent_obj = so2.Id
WHERE
    so.type = 'TR'
    AND OBJECT_NAME(so.parent_obj) LIKE '%%'
    AND so.name LIKE '%%'
ORDER BY
    OBJECT_NAME(so.parent_obj),
    so.name;
#+end_src

#+begin_src sql
SELECT
    OBJECT_NAME(parent_id)              AS TABLE_NAME,
    name                                AS TRIGGER_NAME,
    is_instead_of_trigger               AS INSTEAD_OF,
    is_disabled                         AS DISABLED
FROM sys.triggers
WHERE name LIKE '%%'
ORDER BY
    OBJECT_NAME(parent_id),
    sys.triggers.name;
#+end_src

#+begin_src sql
-- List triggers.
SELECT
    tbl.name                            AS "TABLE",
    trg.name                            AS TRIGGER_NAME,
    CASE
        WHEN is_instead_of_trigger = 1  THEN 'Instead of'
                                        ELSE 'After'
    END                                 AS ACTIVATION,
   (CASE
        WHEN OBJECTPROPERTY(trg.object_id, 'ExecIsInsertTrigger') = 1
                                        THEN 'Insert '
                                        ELSE ''
    END
    +
    CASE
        WHEN OBJECTPROPERTY(trg.object_id, 'ExecIsUpdateTrigger') = 1
                                        THEN 'Update '
                                        ELSE ''
    END
    +
    CASE
        WHEN OBJECTPROPERTY(trg.object_id, 'ExecIsDeleteTrigger') = 1
                                        THEN 'Delete'
                                        ELSE ''
    END)                                AS EVENT,
    CASE
        WHEN trg.parent_class = 1       THEN 'Table trigger'
        WHEN trg.parent_class = 0       THEN 'Database trigger'
    END                                 AS CLASS,
    CASE
        WHEN trg.type = 'TA'            THEN 'Assembly (CLR) trigger'
        WHEN trg.type = 'TR'            THEN 'SQL trigger'
                                        ELSE ''
    END                                 AS TYPE,
    CASE
        WHEN is_disabled = 1            THEN 'Disabled'
                                        ELSE 'Enabled'
    END                                 AS STATUS,
    OBJECT_DEFINITION(trg.object_id)    AS DEFINITION
FROM sys.triggers                       trg
LEFT JOIN sys.objects                   tbl
    ON trg.parent_id = tbl.object_id
WHERE
    tbl.name LIKE '%%'
    AND trg.name LIKE '%%'
ORDER BY
    tbl.name,
    trg.name;
#+end_src

#+begin_warning
*Non-updating updates* (such as ~UPDATE TableName SET field1 = field1~) do fire
~UPDATE~ triggers on the table being updated, and indicate that the field was
updated (if you check using either the ~UPDATE()~ or ~COLUMNS_UPDATED~ functions).

The field in both ~INSERTED~ and ~DELETED~ tables are the same value.
#+end_warning

How often do Update triggers fire on a multi-record update?

Microsoft SQL Server only supports *statement level* triggers: a statement level
trigger will *fire once for the whole statement*.

*** Nested triggers (server option)

Check whether nested triggers are turned on or off.

#+begin_src sql
EXEC sp_configure 'nested triggers';
#+end_src

- If the ~run_value~ is 0, then the nested triggers are off (~AFTER~ triggers cannot
  cascade).

- If the value is 1 (the default), then they are on (~AFTER~ triggers can cascade
  to as many as 32 levels -- If any trigger in the chain sets off an infinite
  loop, the nesting level is exceeded and the trigger is canceled with error
  message).

#+begin_note
~INSTEAD OF~ triggers (which perform their actions /instead of/ the action that
fired them) can be nested regardless of the setting of this option.
#+end_note

*** Recursive triggers (database option)

*Direct recursion* only.

#+begin_src sql
ALTER DATABASE MyDataBase SET RECURSIVE_TRIGGERS ON
go
#+end_src

*** For Oracle

#+begin_src sql
-- List triggers (for Oracle).
SELECT
    table_owner                         AS SCHEMA_NAME,
    table_name                          AS OBJECT_NAME,
    -- owner                               AS TRIGGER_SCHEMA_NAME,
    trigger_name,
    trigger_type,
    triggering_event,
    base_object_type                    AS OBJECT_TYPE,
    status,
    trigger_body                        AS DEFINITION
FROM sys.all_triggers
WHERE
    -- Exclude (some) Oracle default schemas.
    owner NOT IN ('APEX_040200', 'CTXSYS', 'LBACSYS', 'MDSYS', 'OLAPSYS',
                  'ORDDATA', 'ORDSYS', 'SYS', 'SYSTEM', 'WMSYS', 'XDB')
    AND table_name LIKE UPPER('%%')
    AND trigger_name LIKE UPPER('%%')
    -- AND status = 'ENABLED'
ORDER BY
    table_owner,
    table_name,
    trigger_name,
    base_object_type;
#+end_src

*** For AFM cascading_update/delete triggers

#+begin_src sql
SELECT
    'referenced_trigger'                AS trigger_type,
    t.name
FROM sys.triggers                       t
WHERE t.name LIKE '%cascad%'

UNION ALL

SELECT
    'referencing_trigger'               AS trigger_type,
    t.name
FROM sys.triggers                       t
WHERE EXISTS
(
    SELECT 1
    FROM sys.columns                    c
    WHERE OBJECT_NAME(c.object_id) + '_' + c.name + '_t' = t.name
)
ORDER BY 1, 2;
#+end_src

** Using a DML trigger with a reminder e-mail message

The following example sends an e-mail message to a specified person (MaryM) when
the Customer table changes.

#+begin_src sql
CREATE TRIGGER reminder2
ON Sales.Customer
AFTER INSERT, UPDATE, DELETE
AS
   EXEC msdb.dbo.sp_send_dbmail
        @profile_name = 'AdventureWorks2012 Administrator',
        @recipients = 'danw@Adventure-Works.com',
        @body = 'Don''t forget to print a report for the sales force.',
        @subject = 'Reminder';
go
#+end_src

** List all stored procedures and functions

#+begin_src sql
SELECT
    name,
    type
FROM dbo.sysobjects
WHERE type IN (
    'P',                                -- Stored Procedures.
    'TF',                               -- Table-valued Functions.
    'FN',                               -- Scalar-valued Functions.
    'IF'                                -- Inline table-valued Functions.
)
ORDER BY
    type,
    name;
-- Should order by stored proc first, then by functions (like in object explorer).
#+end_src

** List all views, stored procedures, functions and triggers REFERENCING a particular table

#+begin_tip
~EXEC sp_depends~ lists the database objects that depend on a table.  Though, this
stored procedure will be removed in future versions of Microsoft SQL Server.
#+end_tip

A non-query way, using SQL Server Management Studio:
1. locate the table,
2. right-click and
3. choose "*View dependencies*".

#+begin_warning
As commenters said, "View Dependencies" is not very reliable -- and actually
dangerous to use!
#+end_warning

Also use *Red Gate SQL Search* or *ApexSQL Search* (FREE) (in SQL Server Management
Studio) for that...

*View views*, *stored procedures*, *functions* (?) and *triggers* that *depend on*
a particular table.

#+begin_src sql
SELECT
    SCHEMA_NAME(o.SCHEMA_ID) + '.' + o.name AS NAME,
    o.type_desc                         AS TYPE,
    referenced_schema_name              AS REFERENCED_SCHEMA,
    referenced_entity_name              AS REFERENCED_TABLE_NAME,
    o1.type_desc                        AS REFERENCED_OBJECT_TYPE
    --,sed.* -- Uncomment for all the columns.
FROM sys.sql_expression_dependencies    sed
INNER JOIN sys.objects                  o
    ON sed.referencing_id = o.[object_id]
LEFT OUTER JOIN sys.objects             o1
    ON sed.referenced_id = o1.[object_id]
WHERE referenced_entity_name = 'kpi_actuals'
ORDER BY name;
#+end_src

(Less results than with ~EXEC sp_depends~, for example for table ~wr~!?)

Find text in views, stored procedures, functions, triggers, default constraints,
etc.:

#+begin_src sql
SELECT
    SCHEMA_NAME(o.schema_id) + '.' + o.name AS NAME,
    o.type_desc                         AS TYPE,
    OBJECT_DEFINITION(object_id)        AS SOURCE
FROM sys.objects                        o
WHERE
    UPPER(OBJECT_DEFINITION(o.object_id)) LIKE '%' + UPPER('kpi_actuals') + '%'
    AND o.type IN (
        'C',                            -- Check constraint.
        'D',                            -- Default (constraint or stand-alone).
        'P',                            -- SQL stored procedure.
        'FN',                           -- SQL scalar function.
        'R',                            -- Rule.
        'RF',                           -- Replication filter procedure.
        'TR',                           -- SQL trigger (schema-scoped DML trigger, or DDL trigger at either the database or server scope).
        'IF',                           -- SQL inline table-valued function.
        'TF',                           -- SQL table-valued function.
        'V')                            -- View.
ORDER BY o.name;
#+end_src

(More results than with ~EXEC sp_depends~, for example for table ~wr~.)

** List all indexes and index columns

You can also use ~EXEC sp_helpindex~ to view all the indexes (and index columns)
of one table:

#+begin_src sql
EXEC sys.sp_helpindex @objname = N'activity_log'
#+end_src

(It only includes the index key columns, not the included columns.)

** SQL Collation

#+begin_src sql
SELECT
    OBJECT_NAME(object_id)              AS table,
    col.name,
    col.collation_name
FROM sys.columns                        col
ORDER BY
    OBJECT_NAME(object_id),
    col.name;
#+end_src

*NOTE --* Liste des collations de SQL Server :

#+begin_src sql
SELECT *
FROM ::fn_helpcollations();
#+end_src

** Finding and Eliminating Duplicate or Overlapping Indexes

Effective indexing is the key to keeping your queries running quickly while
consuming as few resources as possible in the process.  Each index that is added
to a table will increase the speed of reads that are now able to utilize that
index, but at the cost of speed whenever that index needs to be updated.  In
addition, your index maintenance processes (rebuilding/reorganizing) will now
have an additional index to operate on.

SQL Server has no safeguards against indexes that duplicate behavior, and
therefore a table could conceivably have any number of duplicate or overlapping
indexes on it without your ever knowing they were there!  This would constitute
an unnecessary drain on resources that could easily be avoided.  How do we
easily view our current indexes and determine if duplicates exist?  What about
indexes that contain overlapping column lists that could be combined?

http://www.sqlservercentral.com/articles/Indexing/110106/

The best request out of it?

#+begin_src sql
;WITH CTE_INDEX_DATA AS (
       SELECT
              SCHEMA_DATA.name AS schema_name,
              TABLE_DATA.name AS table_name,
              INDEX_DATA.name AS index_name,
              STUFF((SELECT  ', ' + COLUMN_DATA_KEY_COLS.name + ' ' + CASE WHEN INDEX_COLUMN_DATA_KEY_COLS.is_descending_key = 1 THEN 'DESC' ELSE 'ASC' END -- Include column order (ASC / DESC).

                                  FROM    sys.tables AS T
                                                INNER JOIN sys.indexes INDEX_DATA_KEY_COLS
                                                ON T.object_id = INDEX_DATA_KEY_COLS.object_id
                                                INNER JOIN sys.index_columns INDEX_COLUMN_DATA_KEY_COLS
                                                ON INDEX_DATA_KEY_COLS.object_id = INDEX_COLUMN_DATA_KEY_COLS.object_id
                                                AND INDEX_DATA_KEY_COLS.index_id = INDEX_COLUMN_DATA_KEY_COLS.index_id
                                                INNER JOIN sys.columns COLUMN_DATA_KEY_COLS
                                                ON T.object_id = COLUMN_DATA_KEY_COLS.object_id
                                                AND INDEX_COLUMN_DATA_KEY_COLS.column_id = COLUMN_DATA_KEY_COLS.column_id
                                  WHERE   INDEX_DATA.object_id = INDEX_DATA_KEY_COLS.object_id
                                                AND INDEX_DATA.index_id = INDEX_DATA_KEY_COLS.index_id
                                                AND INDEX_COLUMN_DATA_KEY_COLS.is_included_column = 0
                                  ORDER BY INDEX_COLUMN_DATA_KEY_COLS.key_ordinal
                                  FOR XML PATH('')), 1, 2, '') AS key_column_list ,
          STUFF(( SELECT  ', ' + COLUMN_DATA_INC_COLS.name
                                  FROM    sys.tables AS T
                                                INNER JOIN sys.indexes INDEX_DATA_INC_COLS
                                                ON T.object_id = INDEX_DATA_INC_COLS.object_id
                                                INNER JOIN sys.index_columns INDEX_COLUMN_DATA_INC_COLS
                                                ON INDEX_DATA_INC_COLS.object_id = INDEX_COLUMN_DATA_INC_COLS.object_id
                                                AND INDEX_DATA_INC_COLS.index_id = INDEX_COLUMN_DATA_INC_COLS.index_id
                                                INNER JOIN sys.columns COLUMN_DATA_INC_COLS
                                                ON T.object_id = COLUMN_DATA_INC_COLS.object_id
                                                AND INDEX_COLUMN_DATA_INC_COLS.column_id = COLUMN_DATA_INC_COLS.column_id
                                  WHERE   INDEX_DATA.object_id = INDEX_DATA_INC_COLS.object_id
                                                AND INDEX_DATA.index_id = INDEX_DATA_INC_COLS.index_id
                                                AND INDEX_COLUMN_DATA_INC_COLS.is_included_column = 1
                                  ORDER BY INDEX_COLUMN_DATA_INC_COLS.key_ordinal
                                  FOR XML PATH('')), 1, 2, '') AS include_column_list,
       INDEX_DATA.is_disabled -- Check if index is disabled before determining which dupe to drop (if applicable).
       FROM sys.indexes INDEX_DATA
       INNER JOIN sys.tables TABLE_DATA
       ON TABLE_DATA.object_id = INDEX_DATA.object_id
       INNER JOIN sys.schemas SCHEMA_DATA
       ON SCHEMA_DATA.schema_id = TABLE_DATA.schema_id
       WHERE TABLE_DATA.is_ms_shipped = 0
       AND INDEX_DATA.type_desc IN ('NONCLUSTERED', 'CLUSTERED')
)
SELECT
       *
FROM CTE_INDEX_DATA DUPE1
WHERE EXISTS
(SELECT * FROM CTE_INDEX_DATA DUPE2
 WHERE DUPE1.schema_name = DUPE2.schema_name
 AND DUPE1.table_name = DUPE2.table_name
 AND (DUPE1.key_column_list LIKE LEFT(DUPE2.key_column_list, LEN(DUPE1.key_column_list)) OR DUPE2.key_column_list LIKE LEFT(DUPE1.key_column_list, LEN(DUPE2.key_column_list)))
 AND DUPE1.index_name <> DUPE2.index_name)
#+end_src

*

* Troubleshooting

** Debug code

To debug the code of views, for example,
- simplify it (remove useless subqueries)
- put a SELECT around some code, moving the WHERE conditions around
- don't forget that missed lines are missed because of JOIN conditions or
  because of WHERE conditions... and some conditions may have been written in
  the wrong place!

** SQL Server: After first install of SQL Server

Go to Properties of the Server, tab Security: Enable "SQL Server and Windows
Authentication mode".

Eventually, create the necessary logins...

** SQL Server: No Process Is on the Other End of the Pipe (Error: 233) -- SQL Server not listening on 1433

#+begin_src shell :tangle no
> telnet localhost 1433
Trying 127.0.0.1...
telnet: Unable to connect to remote host: Connection refused
#+end_src

*Cause:* The client protocol order is attempting to connect with the named pipes
protocol before trying the TCP protocol, and named pipes are not enabled on the
server.

(For security reasons, *networking protocols* are *disabled* by default in SQL
Server Express. Individual protocols can be enabled manually or during
installation of SQL Server Express.)

*Resolution:* Using *SQL Server Configuration Manager* on the client computer, move
TCP before named pipes in the protocol order list.

*** Change the default protocol or the protocol order for client computers

- In SQL Server Configuration Manager, expand SQL Server Native Client
  Configuration, right-click Client Protocols, and then click Properties.

- In the Enabled Protocols box, click Move Up or Move Down, to change the order
  in which protocols are tried, when attempting to connect to SQL Server. The
  top protocol in the Enabled Protocols box is the default protocol.

*** Add static port TCP/1433

- Go to "SQL Server Network Configuration"

- *Enable TCP/IP* in "Protocols for SQLEXPRESS"

- In the Properties of TCP/IP > "*IP Addresses*", scroll down to *IPAll* and make
  sure "TCP Dynamic Ports" is blank and that "*TCP Port*" is *set to 1433*.

- Restart the "SQL Server (SQLEXPRESS)" service.

- Make sure that port 1433 is enabled on your personal firewall.

*** Test

#+begin_src shell :tangle no
> telnet localhost 1433
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
#+end_src

#+begin_src shell :tangle no
> sqlcmd -S localhost -d myDB -E
#+end_src
